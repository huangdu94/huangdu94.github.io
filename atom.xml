<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄渡的个人博客</title>
  
  <subtitle>记录一个程序员的成长轨迹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://huangdu.work/"/>
  <updated>2020-03-05T16:00:00.000Z</updated>
  <id>https://huangdu.work/</id>
  
  <author>
    <name>黄渡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elasticsearch笔记（五）</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/database/elasticsearch/elasticsearch%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>https://huangdu.work/笔记/database/elasticsearch/elasticsearch笔记（五）/</id>
    <published>2020-03-05T16:00:00.000Z</published>
    <updated>2020-03-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch笔记（五）"><a href="#Elasticsearch笔记（五）" class="headerlink" title="Elasticsearch笔记（五）"></a>Elasticsearch笔记（五）</h2><h3 id="十三、多字段搜索"><a href="#十三、多字段搜索" class="headerlink" title="十三、多字段搜索"></a>十三、多字段搜索</h3><h4 id="1-多字符串查询"><a href="#1-多字符串查询" class="headerlink" title="1. 多字符串查询"></a>1. 多字符串查询</h4><ol><li><p>最简单的多字段查询可以将搜索项映射到具体的字段。例如<code>War and Peace</code>是标题，<code>Leo Tolstoy</code>是作者，很容易就能把两个条件用<code>match</code>语句表示，并将它们用<code>bool</code>查询组合起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:  &quot;War and Peace&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;author&quot;: &quot;Leo Tolstoy&quot;   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bool</code>查询采取匹配越多越好的方式，所以每条<code>match</code>语句的评分结果会被加在一起，从而为每个文档提供最终的分数<code>_score</code>。能与两条语句同时匹配的文档比只与一条语句匹配的文档得分要高</p></li><li><p>并不是只能使用<code>match</code>语句，也可以用<code>bool</code>查询来包裹组合任意其他类型的查询，甚至包括其他的<code>bool</code>查询。可以在上面的示例中添加一条语句来指定译者版本的偏好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:  &quot;War and Peace&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;author&quot;: &quot;Leo Tolstoy&quot;   &#125;&#125;,</span><br><span class="line">        &#123; &quot;bool&quot;:  &#123;</span><br><span class="line">          &quot;should&quot;: [</span><br><span class="line">            &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Constance Garnett&quot; &#125;&#125;,</span><br><span class="line">            &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Louise Maude&quot;      &#125;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bool</code>查询运行每个<code>match</code>查询，再把评分加在一起，然后将结果与所有匹配的语句数量相乘，最后除以所有的语句数量。处于同一层的每条语句具有相同的权重。在前面这个例子中，包含<code>translator</code>语句的<code>bool</code>查询，只占总评分的三分之一。如果将<code>translator</code>语句与<code>title</code>和<code>author</code>两条语句放入同一层，那么<code>title</code>和<code>author</code>语句只贡献四分之一评分</p></li><li><p>可以使用<code>boost</code>参数提升<code>title</code>和<code>author</code>字段的权重，为它们分配的<code>boost</code>值大于1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123;</span><br><span class="line">            &quot;title&quot;:  &#123;</span><br><span class="line">              &quot;query&quot;: &quot;War and Peace&quot;,</span><br><span class="line">              &quot;boost&quot;: 2</span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123;</span><br><span class="line">            &quot;author&quot;:  &#123;</span><br><span class="line">              &quot;query&quot;: &quot;Leo Tolstoy&quot;,</span><br><span class="line">              &quot;boost&quot;: 2</span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; &quot;bool&quot;:  &#123;</span><br><span class="line">            &quot;should&quot;: [</span><br><span class="line">              &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Constance Garnett&quot; &#125;&#125;,</span><br><span class="line">              &#123; &quot;match&quot;: &#123; &quot;translator&quot;: &quot;Louise Maude&quot;      &#125;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>title</code>和<code>author</code>语句的<code>boost</code>值为2，嵌套<code>bool</code>语句默认的<code>boost</code>值为1</p></li><li><p>要获取<code>boost</code>参数“最佳”值，较为简单的方式就是不断试错。设定<code>boost</code>值，运行测试查询，如此反复。<code>boost</code>值比较合理的区间处于1到10之间，当然也有可能是15。如果为<code>boost</code>指定比这更高的值，将不会对最终的评分结果产生更大影响，因为评分是被归一化的(normalized)</p></li></ol><h4 id="2-单字符串查询"><a href="#2-单字符串查询" class="headerlink" title="2. 单字符串查询"></a>2. 单字符串查询</h4><ol><li><p><code>bool</code>查询是多语句查询的主干。它的适用场景很多，特别是当需要将不同查询字符串映射到不同字段的时候</p></li><li><p>有些用户期望将所有的搜索项堆积到单个字段中，并期望应用程序能为他们提供正确的结果。对于多词(multiword)、多字段(multifield)查询来说，不存在简单的万能方案。为了获得最好结果，需要了解我们的数据，并了解如何使用合适的工具</p></li><li><p>当用户输入了单个字符串查询的时候，通常会遇到以下三种情形</p><ol><li>最佳字段<br>当搜索词语具体概念的时候，比如“brown fox”，词组比各自独立的单词更有意义。像<code>title</code>和<code>body</code>这样的字段，尽管它们之间是相关的，但同时又彼此相互竞争。文档在相同字段中包含的词越多越好，评分也来自于最匹配字段</li><li>多数字段<br>为了对相关度进行微调，常用的一个技术就是将相同的数据索引到不同的字段，它们各自具有独立的分析链。主字段可能包括它们的词源、同义词以及变音词或口音词，被用来匹配尽可能多的文档。相同的文本被索引到其他字段，以提供更精确的匹配。一个字段可以包括未经词干提取过的原词，另一个字段包括其他词源、口音，还有一个字段可以提供词语相似性信息的瓦片词(shingles)。其他字段是作为匹配每个文档时提高相关度评分的信号，匹配字段越多则越好</li><li>混合字段<br>对于某些实体，我们需要在多个字段中确定其信息，单个字段都只能作为整体的一部分。在这种情况下，我们希望在任何这些列出的字段中找到尽可能多的词，这有如在一个大字段中进行搜索，这个大字段包括了所有列出的字段<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person：first_name、last_name</span><br><span class="line">Book：title、author、description</span><br><span class="line">Address：street、city、country、postcode</span><br></pre></td></tr></table></figure></li></ol></li><li><p>上述所有都是多词、多字段查询，但每个具体查询都要求使用不同策略</p></li></ol><h4 id="3-最佳字段"><a href="#3-最佳字段" class="headerlink" title="3. 最佳字段"></a>3. 最佳字段</h4><ol><li><p>假设有个网站允许用户搜索博客的内容，以下面两篇博客内容文档为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Quick brown rabbits&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;Brown rabbits are commonly seen.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;Keeping pets healthy&quot;,</span><br><span class="line">  &quot;body&quot;:  &quot;My quick brown fox eats rabbits on a regular basis.&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用户输入词组“Brown fox”然后点击搜索按钮。事先，我们并不知道用户的搜索项是会在<code>title</code>还是在<code>body</code>字段中被找到，但是，用户很有可能是想搜索相关的词组。用肉眼判断，文档2的匹配度更高，因为它同时包括要查找的两个词。现在运行以下<code>bool</code>查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Brown fox&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Brown fox&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询的结果是文档1的评分更高。文档1的两个字段都包含<code>brown</code>这个词，所以两个<code>match</code>语句都能成功匹配并且有一个评分。文档2的<code>body</code>字段同时包含<code>brown</code>和<code>fox</code>这两个词，但<code>title</code>字段没有包含任何词。这样，<code>body</code>查询结果中的高分，加上<code>title</code>查询中的0分，然后乘以二分之一，就得到比文档1更低的整体评分</p></li><li><p><code>title</code>和<code>body</code>字段是相互竞争的关系，所以就需要找到单个最佳匹配的字段(将最佳匹配字段的评分作为查询的整体评分)</p></li><li><p>不使用<code>bool</code>查询，可以使用<code>dis_max</code>即分离最大化查询(Disjunction Max Query)。分离(Disjunction)的意思是或(or)，这与可以把结合(conjunction)理解成与(and)相对应。分离最大化查询(Disjunction Max Query)指的是：将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;dis_max&quot;: &#123;</span><br><span class="line">      &quot;queries&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Brown fox&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Brown fox&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>得到我们想要的结果，文档2的评分更高</p></li></ol><h4 id="4-最佳字段查询调优"><a href="#4-最佳字段查询调优" class="headerlink" title="4. 最佳字段查询调优"></a>4. 最佳字段查询调优</h4><ol><li><p>当用户搜索“quick pets”时会发生什么呢？在前面的例子中，两个文档都包含词quick，但是只有文档2包含词pets，两个文档中都不具有同时包含两个词的相同字段</p></li><li><p>一个简单的<code>dis_max</code>查询会采用单个最佳匹配字段，而忽略其他的匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;dis_max&quot;: &#123;</span><br><span class="line">      &quot;queries&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果是两个评分是完全相同的。我们可能期望同时匹配<code>title</code>和<code>body</code>字段的文档比只与一个字段匹配的文档的相关度更高，但事实并非如此，因为<code>dis_max</code>查询只会简单地使用单个最佳匹配语句的评分<code>_score</code>作为整体评分</p></li><li><p>可以通过指定<code>tie_breaker</code>这个参数将其他匹配语句的评分也考虑其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;dis_max&quot;: &#123;</span><br><span class="line">      &quot;queries&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;Quick pets&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;body&quot;:  &quot;Quick pets&quot; &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;tie_breaker&quot;: 0.3</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果是文档2的相关度比文档1略高</p></li><li><p><code>tie_breaker</code>参数提供了一种<code>dis_max</code>和<code>bool</code>之间的折中选择，它的评分方式为：获得最佳匹配语句的评分<code>_score</code>；将其他匹配语句的评分结果与<code>tie_breaker</code>相乘；对以上评分求和并规范化。有了tie_breaker，会考虑所有匹配语句，但最佳匹配语句依然占最终结果里的很大一部分</p></li><li><p><code>tie_breaker</code>可以是0到1之间的浮点数，其中0代表使用<code>dis_max</code>最佳匹配语句的普通逻辑，1表示所有匹配语句同等重要。最佳的精确值需要根据数据与查询调试得出，但是合理值应该与零接近(处于0.1-0.4之间)，这样就不会颠覆<code>dis_max</code>最佳匹配性质的根本</p></li></ol><h4 id="5-multi-match查询"><a href="#5-multi-match查询" class="headerlink" title="5. multi_match查询"></a>5. multi_match查询</h4><ol><li><p><code>multi_match</code>查询为能在多个字段上反复执行相同查询提供了一种便捷方式。<code>multi_match</code>多匹配查询的类型有多种，其中的三种恰巧与了解我们的数据中介绍的三个场景对应，即：<code>best_fields</code>、<code>most_fields</code>和<code>cross_fields</code>(最佳字段、多数字段、跨字段)</p></li><li><p>默认情况下，查询的类型是<code>best_fields</code>，这表示它会为每个字段生成一个<code>match</code>查询，然后将它们组合到<code>dis_max</code>查询的内部，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;dis_max&quot;: &#123;</span><br><span class="line">    &quot;queries&quot;:  [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;title&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Quick brown fox&quot;,</span><br><span class="line">            &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;body&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Quick brown fox&quot;,</span><br><span class="line">            &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    &quot;tie_breaker&quot;: 0.3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面这个查询用<code>multi_match</code>重写成更简洁的形式(best_fields类型是默认值，可以不指定)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;multi_match&quot;: &#123;</span><br><span class="line">    &quot;query&quot;:                &quot;Quick brown fox&quot;,</span><br><span class="line">    &quot;type&quot;:                 &quot;best_fields&quot;,</span><br><span class="line">    &quot;fields&quot;:               [ &quot;title&quot;, &quot;body&quot; ],</span><br><span class="line">    &quot;tie_breaker&quot;:          0.3,</span><br><span class="line">    &quot;minimum_should_match&quot;: &quot;30%&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字段名称可以用模糊匹配的方式给出：任何与模糊模式正则匹配的字段都会被包括在搜索条件中，例如可以使用以下方式同时匹配<code>book_title</code>、<code>chapter_title</code>和<code>section_title</code>(书名、章名、节名)这三个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;multi_match&quot;: &#123;</span><br><span class="line">    &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">    &quot;fields&quot;: &quot;*_title&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>^</code>字符语法为单个字段提升权重，在字段名称的末尾添加<code>^boost</code>，其中<code>boost</code>是一个浮点数(<code>chapter_title</code>这个字段的<code>boost</code>值为2，而其他两个字段<code>book_title</code>和<code>section_title</code>字段的默认<code>boost</code>值为1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;multi_match&quot;: &#123;</span><br><span class="line">    &quot;query&quot;:  &quot;Quick brown fox&quot;,</span><br><span class="line">    &quot;fields&quot;: [ &quot;*_title&quot;, &quot;chapter_title^2&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-多数字段"><a href="#6-多数字段" class="headerlink" title="6. 多数字段"></a>6. 多数字段</h4><ol><li><p>全文搜索被称作是召回率(Recall,返回所有的相关文档)与精确率(Precision,不返回无关文档)的战场，目的是在结果的第一页中为用户呈现最为相关的文档。为了提高召回率的效果，我们扩大搜索范围，不仅返回与用户搜索词精确匹配的文档，还会返回我们认为与查询相关的所有文档</p></li><li><p>如果一个用户搜索“quick brown box”，一个包含词语fast foxes的文档被认为是非常合理的返回结果。如果包含词语fast foxes的文档是能找到的唯一相关文档，那么它会出现在结果列表的最上面，但是，如果有100个文档都出现了词语quick brown fox，那么这个包含词语fast foxes的文档当然会被认为是次相关的，它可能处于返回结果列表更下面的某个地方。当包含了很多潜在匹配之后，我们需要将最匹配的几个置于结果列表的顶部</p></li><li><p>提高全文相关性精度的常用方式是为同一文本建立多种方式的索引，每种方式都提供了一个不同的相关度信号signal。主字段会以尽可能多的形式的去匹配尽可能多的文档。举个例子，我们可以进行以下操作：</p><ol><li>使用词干提取来索引jumps、jumping和jumped样的词，将jump作为它们的词根形式。这样即使用户搜索jumped，也还是能找到包含jumping的匹配的文档</li><li>将同义词包括其中，如jump、leap和hop</li><li>移除变音或口音词：如ésta、está和esta都会以无变音形式esta来索引</li></ol></li><li><p>尽管如此，如果我们有两个文档，其中一个包含词jumped，另一个包含词jumping，用户很可能期望前者能排的更高，因为它正好与输入的搜索条件一致。为了达到目的，我们可以将相同的文本索引到其他字段从而提供更为精确的匹配。一个字段可能是为词干未提取过的版本，另一个字段可能是变音过的原始词，第三个可能使用shingles提供词语相似性信息。这些附加的字段可以看成提高每个文档的相关度评分的信号signals，能匹配字段的越多越好</p></li><li><p>一个文档如果与广度匹配的主字段相匹配，那么它会出现在结果列表中。如果文档同时又与signal信号字段匹配，那么它会获得额外加分，系统会提升它在结果列表中的位置</p></li><li><p>稍后对同义词、词相似性、部分匹配以及其他潜在的信号进行讨论，但这里只使用词干已提取(stemmed)和未提取(unstemmed)的字段作为简单例子来说明这种技术</p></li><li><p>首先要做的事情就是对我们的字段索引两次：一次使用词干模式以及一次非词干模式。为了做到这点，采用<code>multifields</code>来实现，已经在<code>multifields</code>有所介绍</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1 &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;english&quot;,</span><br><span class="line">          &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;std&quot;:   &#123;</span><br><span class="line">              &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">              &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接着索引一些文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123; &quot;title&quot;: &quot;My rabbit jumps&quot; &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123; &quot;title&quot;: &quot;Jumping jack rabbits&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p>这里用一个简单<code>match</code>查询<code>title</code>标题字段是否包含jumping rabbits</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;jumping rabbits&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为有了english分析器，这个查询是在查找以jump和rabbit这两个被提取词的文档。两个文档的<code>title</code>字段都同时包括这两个词，所以两个文档得到的评分也相同</p></li><li><p>如果只是查询<code>title.std</code>字段，那么只有文档2是匹配的。尽管如此，如果同时查询两个字段，然后使用bool查询将评分结果合并，那么两个文档都是匹配的(<code>title</code>字段的作用)，而且文档2的相关度评分更高(<code>title.std</code>字段的作用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:  &quot;jumping rabbits&quot;,</span><br><span class="line">        &quot;type&quot;:   &quot;most_fields&quot;, (1)</span><br><span class="line">        &quot;fields&quot;: [ &quot;title&quot;, &quot;title.std&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们希望将所有匹配字段的评分合并起来，所以使用<code>most_fields</code>类型。这让<code>multi_match</code>查询用<code>bool</code>查询将两个字段语句包在里面，而不是使用<code>dis_max</code>查询</p></li><li><p>结果文档2现在的评分要比文档1高。用广度匹配字段<code>title</code>包括尽可能多的文档以提升召回率，同时又使用字段<code>title.std</code>作为信号将相关度更高的文档置于结果顶部</p></li><li><p>每个字段对于最终评分的贡献可以通过自定义值<code>boost</code>来控制。比如，使<code>title</code>字段更为重要，这样同时也降低了其他信号字段的作用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;jumping rabbits&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;title^10&quot;, &quot;title.std&quot; ] (1)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="7-跨字段实体搜索"><a href="#7-跨字段实体搜索" class="headerlink" title="7. 跨字段实体搜索"></a>7. 跨字段实体搜索</h4><ol><li><p>现在讨论一种普遍的搜索模式：跨字段实体搜索(cross-fields entity search)。在如person、 product或address这样的实体中，需要使用多个字段来唯一标识它的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstname&quot;:  &quot;Peter&quot;,</span><br><span class="line">  &quot;lastname&quot;:   &quot;Smith&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;street&quot;:   &quot;5 Poland Street&quot;,</span><br><span class="line">  &quot;city&quot;:     &quot;London&quot;,</span><br><span class="line">  &quot;country&quot;:  &quot;United Kingdom&quot;,</span><br><span class="line">  &quot;postcode&quot;: &quot;W1V 3DG&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这与之前描述的多字符串查询很像，但这存在着巨大的区别。在多字符串查询中，我们为每个字段使用不同的字符串，在本例中，我们想使用单个字符串在多个字段中进行搜索。我们的用户可能想搜索“Peter Smith”这个人，或“Poland Street W1V”这个地址，这些词出现在不同的字段中，所以如果使用<code>dis_max</code>或<code>best_fields</code>查询去查找单个最佳匹配字段显然是个错误的方式</p></li><li><p>依次查询每个字段并将每个字段的匹配评分结果相加，听起来真像是<code>bool</code>查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;street&quot;:    &quot;Poland Street W1V&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;city&quot;:      &quot;Poland Street W1V&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;country&quot;:   &quot;Poland Street W1V&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;postcode&quot;:  &quot;Poland Street W1V&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为每个字段重复查询字符串会使查询瞬间变得冗长，可以采用<code>multi_match</code>查询，将<code>type</code>设置成<code>most_fields</code>然后告诉Elasticsearch合并所有匹配字段的评分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;Poland Street W1V&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用most_fields这种方式搜索也存在某些问题，这些问题并不会马上显现</p><ol><li>它是为多数字段匹配任意词设计的，而不是在所有字段中找到最匹配的；</li><li>它不能使用<code>operator</code>或<code>minimum_should_match</code>参数来降低次相关结果造成的长尾效应；</li><li>词频对于每个字段是不一样的，而且它们之间的相互影响会导致不好的排序结果</li></ol></li></ol><h4 id="8-字段中心式查询"><a href="#8-字段中心式查询" class="headerlink" title="8. 字段中心式查询"></a>8. 字段中心式查询</h4><ol><li><p>以上三个源于<code>most_fields</code>的问题都因为它是字段中心式(field-centric)而不是词中心式(term-centric)的：当真正感兴趣的是匹配词的时候，它为我们查找的是最匹配的字段。best_fields类型也是字段中心式的，它也存在类似的问题</p></li><li><p>首先查看这些问题存在的原因，再想如何解决它们</p><ol><li><p>问题1：在多个字段中匹配相同的词<br><code>most_fields</code>查询为每个字段生成独立的<code>match</code>查询，再用<code>bool</code>查询将他们包起来。可以通过<code>validate-queryAPI</code>查看。可以发现，两个字段都与poland匹配的文档要比一个字段同时匹配poland与street文档的评分高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">&quot;multi_match&quot;: &#123;</span><br><span class="line">  &quot;query&quot;:   &quot;Poland Street W1V&quot;,</span><br><span class="line">  &quot;type&quot;:    &quot;most_fields&quot;,</span><br><span class="line">  &quot;fields&quot;:  [ &quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(street:poland   street:street   street:w1v)</span><br><span class="line">(city:poland     city:street     city:w1v)</span><br><span class="line">(country:poland  country:street  country:w1v)</span><br><span class="line">(postcode:poland postcode:street postcode:w1v)</span><br></pre></td></tr></table></figure></li><li><p>问题2：剪掉长尾<br>在匹配精度中，我们讨论过使用<code>and</code>操作符或设置<code>minimum_should_match</code>参数来消除结果中几乎不相关的长尾，或许可以尝试以下方式。换句话说，使用<code>and</code>操作符要求所有词都必须存在于相同字段，这显然是不对的！可能就不存在能与这个查询匹配的文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;query&quot;: &#123;</span><br><span class="line">&quot;multi_match&quot;: &#123;</span><br><span class="line">  &quot;query&quot;:       &quot;Poland Street W1V&quot;,</span><br><span class="line">  &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">  &quot;operator&quot;:    &quot;and&quot;,</span><br><span class="line">  &quot;fields&quot;:      [ &quot;street&quot;, &quot;city&quot;, &quot;country&quot;, &quot;postcode&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(+street:poland   +street:street   +street:w1v)</span><br><span class="line">(+city:poland     +city:street     +city:w1v)</span><br><span class="line">(+country:poland  +country:street  +country:w1v)</span><br><span class="line">(+postcode:poland +postcode:street +postcode:w1v)</span><br></pre></td></tr></table></figure></li><li><p>问题3：词频(一个词在单个文档的某个字段中出现的频率越高，这个文档的相关度就越高；一个词在所有文档某个字段索引中出现的频率越高，这个词的相关度就越低)<br>在什么是相关中，我们解释过每个词默认使用TF/IDF相似度算法计算相关度评分。当搜索多个字段时，TF/IDF会带来某些令人意外的结果。想想用字段first_name和last_name查询“Peter Smith”的例子，Peter是个平常的名Smith也是平常的姓，这两者都具有较低的IDF值。但当索引中有另外一个人的名字是“Smith Williams”时，Smith作为名来说很不平常，以致它有一个较高的IDF值！下面这个简单的查询可能会在结果中将“Smith Williams”置于“Peter Smith”之上，尽管事实上是第二个人比第一个人更为匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">&quot;multi_match&quot;: &#123;</span><br><span class="line">   &quot;query&quot;:       &quot;Peter Smith&quot;,</span><br><span class="line">  &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">  &quot;fields&quot;:      [ &quot;*_name&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>存在这些问题仅仅是因为我们在处理着多个字段，如果将所有这些字段组合成单个字段，问题就会消失。可以为person文档添加full_name字段来解决这个问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;first_name&quot;:  &quot;Peter&quot;,</span><br><span class="line">  &quot;last_name&quot;:   &quot;Smith&quot;,</span><br><span class="line">  &quot;full_name&quot;:   &quot;Peter Smith&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当查询full_name字段时，具有更多匹配词的文档会比只有一个重复匹配词的文档更重要。<code>minimum_should_match</code>和<code>operator</code>参数会像期望那样工作。姓和名的逆向文档频率被合并，所以Smith到底是作为姓还是作为名出现，都会变得无关紧要。这么做当然是可行的，但我们并不太喜欢存储冗余数据。取而代之的是Elasticsearch可以提供两个解决方案(一个在索引时，而另一个是在搜索时)</p></li></ol><h4 id="9-自定义-all字段"><a href="#9-自定义-all字段" class="headerlink" title="9. 自定义_all字段"></a>9. 自定义_all字段</h4><ol><li><p>在all-field字段中，我们解释过<code>_all</code>字段的索引方式是将所有其他字段的值作为一个大字符串索引的。然而这么做并不十分灵活，为了灵活我们可以给人名添加一个自定义<code>_all</code>字段，再为地址添加另一个<code>_all</code>字段。Elasticsearch在字段映射中为我们提供<code>copy_to</code>参数来实现这个功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;person&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">          &quot;copy_to&quot;:  &quot;full_name&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;last_name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">          &quot;copy_to&quot;:  &quot;full_name&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;full_name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>first_name</code>和<code>last_name</code>字段中的值会被复制到<code>full_name</code>字段。有了这个映射，我们可以用<code>first_name</code>来查询名，用<code>last_name</code>来查询姓，或者直接使用<code>full_name</code>查询整个姓名。<code>first_name</code>和<code>last_name</code>的映射并不影响<code>full_name</code>如何被索引，<code>full_name</code>将两个字段的内容复制到本地，然后根据<code>full_name</code>的映射自行索引</p></li><li><p><code>copy_to</code>设置对<code>multi-field</code>无效。如果尝试这样配置映射，Elasticsearch会抛异常。多字段只是以不同方式简单索引“主”字段；它们没有自己的数据源。也就是说没有可供<code>copy_to</code>到另一字段的数据源。只要对“主”字段<code>copy_to</code>就能轻而易举的达到相同的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;person&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &#123;</span><br><span class="line">          &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">          &quot;copy_to&quot;:  &quot;full_name&quot;,</span><br><span class="line">          &quot;fields&quot;: &#123;</span><br><span class="line">            &quot;raw&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">              &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;full_name&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:     &quot;string&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="10-cross-fields跨字段查询"><a href="#10-cross-fields跨字段查询" class="headerlink" title="10. cross-fields跨字段查询"></a>10. cross-fields跨字段查询</h4><ol><li>自定义<code>all</code>的方式是一个好的解决方案，只需在索引文档前为其设置好映射。不过，Elasticsearch还在搜索时提供了相应的解决方案：使用<code>cross_fields</code>类型进行<code>multi_match</code>查询。<code>cross_fields</code>使用词中心式(term-centric)的查询方式，这与<code>best_fields</code>和<code>most_fields</code>使用字段中心式(field-centric)的查询方式非常不同，它将所有字段当成一个大字段，并在_每个字段中查找每个词</li><li>为了说明字段中心式(field-centric)与词中心式(term-centric)这两种查询方式的不同，先看看以下字段中心式的<code>most_fields</code>查询的<code>explanation</code>解释<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;peter smith&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;most_fields&quot;,</span><br><span class="line">      &quot;operator&quot;:    &quot;and&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;first_name&quot;, &quot;last_name&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+first_name:peter +first_name:smith)</span><br><span class="line">(+last_name:peter  +last_name:smith)</span><br></pre></td></tr></table></figure><ol start="3"><li><p>词中心式会使用以下逻辑(词peter和smith都必须出现，但是可以出现在任意字段中)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+(first_name:peter last_name:peter)</span><br><span class="line">+(first_name:smith last_name:smith)</span><br></pre></td></tr></table></figure></li><li><p><code>cross_fields</code>类型首先分析查询字符串并生成一个词列表，然后它从所有字段中依次搜索每个词。这种不同的搜索方式很自然的解决了字段中心式查询三个问题中的二个。剩下的问题是逆向文档频率不同。幸运的是<code>cross_fields</code>类型也能解决这个问题，通过<code>validate-query</code>可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;peter smith&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;cross_fields&quot;,</span><br><span class="line">      &quot;operator&quot;:    &quot;and&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;first_name&quot;, &quot;last_name&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+blended(&quot;peter&quot;, fields: [first_name, last_name])</span><br><span class="line">+blended(&quot;smith&quot;, fields: [first_name, last_name])</span><br></pre></td></tr></table></figure><ol start="5"><li><p>换句话说，它会同时在first_name和last_name两个字段中查找smith的IDF，然后用两者的最小值作为两个字段的IDF。结果实际上就是smith会被认为既是个平常的姓，也是平常的名</p></li><li><p>为了让<code>cross_fields</code>查询以最优方式工作，所有的字段都须使用相同的分析器，具有相同分析器的字段会被分组在一起作为混合字段使用</p></li><li><p>如果包括了不同分析链的字段，它们会以<code>best_fields</code>的相同方式被加入到查询结果中。例如：我们将<code>title</code>字段加到之前的查询中(假设它们使用的是不同的分析器)，explanation的解释结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(+title:peter +title:smith)</span><br><span class="line">(</span><br><span class="line">  +blended(&quot;peter&quot;, fields: [first_name, last_name])</span><br><span class="line">  +blended(&quot;smith&quot;, fields: [first_name, last_name])</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>采用<code>cross_fields</code>查询与自定义<code>_all</code>字段相比，其中一个优势就是它可以在搜索时为单个字段提升权重。这对像<code>first_name</code>和<code>last_name</code>具有相同值的字段并不是必须的，但如果要用<code>title</code>和<code>description</code>字段搜索图书，可能希望为<code>title</code>分配更多的权重，这同样可以使用前面介绍过的<code>^</code>符号语法来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /books/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;peter smith&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;cross_fields&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;title^2&quot;, &quot;description&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义单字段查询是否能够优于多字段查询，取决于在多字段查询与单字段自定义<code>_all</code>之间代价的权衡，即哪种解决方案会带来更大的性能优化就选择哪一种</p></li></ol><h4 id="11-Exact-Value精确值字段"><a href="#11-Exact-Value精确值字段" class="headerlink" title="11. Exact-Value精确值字段"></a>11. Exact-Value精确值字段</h4><ol><li><p>在结束多字段查询这个话题之前，我们最后要讨论的是精确值<code>not_analyzed</code>未分析字段。将<code>not_analyzed</code>字段与<code>multi_match</code>中<code>analyzed</code>字段混在一起没有多大用处。原因可以通过查看查询的<code>explanation</code>解释得到，设想将<code>title</code>字段设置成<code>not_analyzed</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:       &quot;peter smith&quot;,</span><br><span class="line">      &quot;type&quot;:        &quot;cross_fields&quot;,</span><br><span class="line">      &quot;fields&quot;:      [ &quot;title&quot;, &quot;first_name&quot;, &quot;last_name&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>因为<code>title</code>字段是未分析过的，Elasticsearch会将“petersmith”这个完整的字符串作为查询条件来搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title:peter smith</span><br><span class="line">(</span><br><span class="line">  blended(&quot;peter&quot;, fields: [first_name, last_name])</span><br><span class="line">  blended(&quot;smith&quot;, fields: [first_name, last_name])</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>显然这个项不在<code>title</code>的倒排索引中，所以需要在<code>multi_match</code>查询中避免使用<code>not_analyzed</code>字段</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch笔记（五）&quot;&gt;&lt;a href=&quot;#Elasticsearch笔记（五）&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch笔记（五）&quot;&gt;&lt;/a&gt;Elasticsearch笔记（五）&lt;/h2&gt;&lt;h3 id=&quot;十
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="database" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/"/>
    
      <category term="elasticsearch" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://huangdu.work/tags/elasticsearch/"/>
    
      <category term="非关系型数据库" scheme="https://huangdu.work/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记（四）</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/database/elasticsearch/elasticsearch%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://huangdu.work/笔记/database/elasticsearch/elasticsearch笔记（四）/</id>
    <published>2020-02-04T16:00:00.000Z</published>
    <updated>2020-02-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch笔记（四）"><a href="#Elasticsearch笔记（四）" class="headerlink" title="Elasticsearch笔记（四）"></a>Elasticsearch笔记（四）</h2><h3 id="十一、结构化搜索"><a href="#十一、结构化搜索" class="headerlink" title="十一、结构化搜索"></a>十一、结构化搜索</h3><h4 id="1-精确值查找"><a href="#1-精确值查找" class="headerlink" title="1. 精确值查找"></a>1. 精确值查找</h4><ol><li><p>制造数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST /my_store/products/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 10, &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 20, &quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;price&quot; : 30, &quot;productID&quot; : &quot;QQPX-R-3956-#aD8&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>term</code>查询数字</p><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  price = 20</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123;</span><br><span class="line">          &quot;price&quot; : 20</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>term</code>查询文本</p><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT product</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  productID = &quot;XHDK-A-1293-#fJ3&quot;</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;term&quot; : &#123;</span><br><span class="line">          &quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发现查询不到，查看<code>productID</code>分词情况(因为字段被分词所以无法查询到精确值)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;productID&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;XHDK-A-1293-#fJ3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重建索引，设置<code>productID</code>不分词(删除索引，重建索引，重新导入数据)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_store</span><br><span class="line">PUT /my_store</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot; : &#123;</span><br><span class="line">    &quot;products&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;productID&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;string&quot;,</span><br><span class="line">          &quot;index&quot; : &quot;not_analyzed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>重新查询即可查询到</p></li></ul></li><li><p>内部过滤器的操作</p><ul><li>在内部，Elasticsearch会在运行非评分查询的时执行多个操作</li></ul><ol><li>查找匹配文档</li><li>创建bitset(一个包含0和1的数组，匹配文档标1，没匹配标0)</li><li>迭代bitsets(一般来说先迭代稀疏的bitset，可以排除掉大量的文档)</li><li>增量使用计数，只缓存那些在将来会被再次使用的查询，以避免资源的浪费</li></ol><ul><li>从概念上记住非评分计算是首先执行的，这将有助于写出高效又快速的搜索请求</li></ul></li></ol><h4 id="2-组合过滤器"><a href="#2-组合过滤器" class="headerlink" title="2. 组合过滤器"></a>2. 组合过滤器</h4><ol><li><p>布尔过滤器(一个<code>bool</code>过滤器由三部分组成，分别与<code>AND</code>、<code>NOT</code>和<code>OR</code>等价)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   &quot;bool&quot; : &#123;</span><br><span class="line">      &quot;must&quot; :     [],</span><br><span class="line">      &quot;should&quot; :   [],</span><br><span class="line">      &quot;must_not&quot; : []</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT product</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  (price = 20 OR productID = &quot;XHDK-A-1293-#fJ3&quot;)</span><br><span class="line">  AND  (price != 30)</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">          &quot;should&quot; : [</span><br><span class="line">            &#123; &quot;term&quot; : &#123;&quot;price&quot; : 20&#125;&#125;,</span><br><span class="line">            &#123; &quot;term&quot; : &#123;&quot;productID&quot; : &quot;XHDK-A-1293-#fJ3&quot;&#125;&#125;</span><br><span class="line">          ],</span><br><span class="line">          &quot;must_not&quot; : &#123;</span><br><span class="line">            &quot;term&quot; : &#123;&quot;price&quot; : 30&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>嵌套布尔过滤器</p><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  productID      = &quot;KDKE-B-9947-#kL5&quot;</span><br><span class="line">  OR (     productID = &quot;JODL-X-1937-#pV7&quot;</span><br><span class="line">       AND price     = 30 )</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">          &quot;should&quot; : [</span><br><span class="line">            &#123; &quot;term&quot; : &#123;&quot;productID&quot; : &quot;KDKE-B-9947-#kL5&quot;&#125;&#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;bool&quot; : &#123;</span><br><span class="line">                &quot;must&quot; : [</span><br><span class="line">                  &#123;&quot;term&quot; : &#123;&quot;productID&quot; : &quot;JODL-X-1937-#pV7&quot;&#125;&#125;,</span><br><span class="line">                  &#123;&quot;term&quot; : &#123;&quot;price&quot; : 30&#125;&#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="3-查找多个精确值"><a href="#3-查找多个精确值" class="headerlink" title="3. 查找多个精确值"></a>3. 查找多个精确值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;terms&quot; : &#123;</span><br><span class="line">          &quot;price&quot; : [20, 30]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-包含，而不是相等"><a href="#4-包含，而不是相等" class="headerlink" title="4. 包含，而不是相等"></a>4. 包含，而不是相等</h4><ul><li><p>一定要了解term和terms是包含(contains)操作，而非等值(equals)</p></li><li><p>例如<code>{ &quot;term&quot; : { &quot;tags&quot; : &quot;search&quot; } }</code>过滤器会匹配到以下两个文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;] &#125;</span><br><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;, &quot;open_source&quot;] &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一定期望整个字段完全相等，最好的方式是增加并索引另一个字段，这个字段用以存储该字段包含词项的数量，同样以上面提到的两个文档为例，现在我们包括了一个维护标签数的新字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;], &quot;tag_count&quot; : 1 &#125;</span><br><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;, &quot;open_source&quot;], &quot;tag_count&quot; : 2 &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以构造一个<code>constant_score</code>查询，来确保结果中的文档所包含的词项数量与要求是一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;bool&quot; : &#123;</span><br><span class="line">          &quot;must&quot; : [</span><br><span class="line">            &#123; &quot;term&quot; : &#123; &quot;tags&quot; : &quot;search&quot; &#125; &#125;,</span><br><span class="line">            &#123; &quot;term&quot; : &#123; &quot;tag_count&quot; : 1 &#125; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-范围"><a href="#5-范围" class="headerlink" title="5. 范围"></a>5. 范围</h4><ul><li><code>range</code>查询可同时提供包含(inclusive)和不包含(exclusive)这两种范围表达式，可供组合的选项如下<ul><li><code>gt</code>:<code>&gt;</code>大于(greater than)</li><li><code>lt</code>:<code>&lt;</code>小于(less than)</li><li><code>gte</code>:<code>&gt;=</code>大于或等于(greater than or equal to)</li><li><code>lte</code>:<code>&lt;=</code>小于或等于(less than or equal to)</li></ul></li></ul><ol><li><p>数字范围</p><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT document</span><br><span class="line">FROM   products</span><br><span class="line">WHERE  price BETWEEN 20 AND 40</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">          &quot;price&quot; : &#123;</span><br><span class="line">            &quot;gte&quot; : 20,</span><br><span class="line">            &quot;lt&quot;  : 40</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想要范围无界(比方说大于20)，只须省略其中一边的限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">  &quot;price&quot; : &#123;</span><br><span class="line">    &quot;gt&quot; : 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>日期范围</p><ul><li><p><code>range</code>查询同样可以应用在日期字段上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">  &quot;timestamp&quot; : &#123;</span><br><span class="line">    &quot;gt&quot; : &quot;2014-01-01 00:00:00&quot;,</span><br><span class="line">    &quot;lt&quot; : &quot;2014-01-07 00:00:00&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>range</code>查询支持对日期计算(date math)进行操作(例：查找时间戳在过去一小时内的所有文档)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;gt&quot; : &quot;now-1h&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>日期计算还可以被应用到某个具体的时间，并非只能是一个像<code>now</code>这样的占位符(只要在某个日期后加上一个双管符号<code>||</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;timestamp&quot; : &#123;</span><br><span class="line">        &quot;gt&quot; : &quot;2014-01-01 00:00:00&quot;,</span><br><span class="line">        &quot;lt&quot; : &quot;2014-01-01 00:00:00||+1M&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串范围</p><ul><li><p><code>range</code>查询同样可以处理字符串字段，字符串范围可采用字典顺序(lexicographically)或字母顺序(alphabetically)</p></li><li><p>在倒排索引中的词项就是采取字典顺序排列的，例：<code>5,50,6,B,C,a,ab,abb,abc,b</code></p></li><li><p>查找从a到b(不包含)的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;range&quot; : &#123;</span><br><span class="line">    &quot;title&quot; : &#123;</span><br><span class="line">        &quot;gte&quot; : &quot;a&quot;,</span><br><span class="line">        &quot;lt&quot; :  &quot;b&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数字和日期字段的索引方式使高效地范围计算成为可能。但字符串却并非如此，要想对其使用范围过滤，Elasticsearch实际上是在为范围内的每个词项都执行<code>term</code>过滤器，这会比日期或数字的范围过滤慢许多</p></li><li><p>字符串范围在过滤低基数(low cardinality)字段(即只有少量唯一词项)时可以正常工作，但是唯一词项越多，字符串范围的计算会越慢</p></li></ul></li></ol><h4 id="6-处理NULL值"><a href="#6-处理NULL值" class="headerlink" title="6. 处理NULL值"></a>6. 处理NULL值</h4><ul><li>如果一个字段没有值(包括<code>&quot;&quot;</code> <code>[]</code> <code>null</code> <code>[null]</code>)，那么它不会被存入倒排索引中</li></ul><ol><li><p>存在查询</p><ul><li><p>制造数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /my_index/posts/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;1&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;]&#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;2&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;, &quot;open_source&quot;]&#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;3&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;other_field&quot; : &quot;some data&quot;&#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;4&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;tags&quot; : null&#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: &quot;5&quot;&#125;&#125;</span><br><span class="line">&#123; &quot;tags&quot; : [&quot;search&quot;, null]&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上文档集合中<code>tags</code>字段对应的倒排索引如下</p><table><thead><tr><th align="center">Token</th><th align="center">DocIDs</th></tr></thead><tbody><tr><td align="center">open_source</td><td align="center">2</td></tr><tr><td align="center">search</td><td align="center">1,2,5</td></tr></tbody></table></li><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tags</span><br><span class="line">FROM   posts</span><br><span class="line">WHERE  tags IS NOT NULL</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;exists&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>缺失查询</p><ul><li><p>SQL语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT tags</span><br><span class="line">FROM   posts</span><br><span class="line">WHERE  tags IS NULL</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch的查询表达式(query DSL)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;constant_score&quot; : &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;missing&quot; : &#123; &quot;field&quot; : &quot;tags&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象上的存在与缺失</p><ul><li><p>不仅可以过滤核心类型，<code>exists</code>和<code>missing</code>查询还可以处理一个对象的内部字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &#123;</span><br><span class="line">    &quot;first&quot; : &quot;John&quot;,</span><br><span class="line">    &quot;last&quot; :  &quot;Smith&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在映射中，如上对象的内部是个扁平的字段与值(field-value)的简单键值结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name.first&quot; : &quot;John&quot;,</span><br><span class="line">  &quot;name.last&quot;  : &quot;Smith&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行下面这个过滤的时候</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exists&quot; : &#123; &quot;field&quot; : &quot;name&quot; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实际执行的是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;name.first&quot; &#125;&#125;,</span><br><span class="line">      &#123; &quot;exists&quot;: &#123; &quot;field&quot;: &quot;name.last&quot; &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>null</code>值设置</p><ul><li>有时候我们需要区分一个字段是没有值，还是它已被显式的设置成了<code>null</code>。默认的行为是无法做到这点的，数据被丢失了。但是可以选择将显式的<code>null</code>值替换成我们指定占位符(placeholder)</li><li>当insert或update数据遇到空值时，将使用该值，这个显式的空值会对其进行索引，以便于搜索</li><li>在为字符串(string)、数字(numeric)、布尔值(Boolean)或日期(date)字段指定映射时，同样可以为之设置<code>null_value</code>空值，用以处理显式<code>null</code>值的情况。不过即使如此，还是会将一个没有值的字段从倒排索引中排除</li><li>当选择合适的<code>null_value</code>空值的时候，需要保证以下几点：<ol><li>它会匹配字段的类型，我们不能为一个date日期字段设置字符串类型的<code>null_value</code></li><li>它必须与普通值不一样，这可以避免把实际值当成<code>null</code>空的情况</li></ol></li><li>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;status_code&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;null_value&quot;: &quot;NULL&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="7-关于缓存"><a href="#7-关于缓存" class="headerlink" title="7. 关于缓存"></a>7. 关于缓存</h4><ul><li>过滤器的内部操作核心实际是采用一个bitset记录与过滤器匹配的文档。Elasticsearch积极地把这些bitset缓存起来以备随后使用，bitset可以复用任何已使用过的相同过滤器，而无需再次计算整个过滤器</li><li>这些bitsets缓存是智能的，它们以增量方式更新。当我们索引新文档时，只需将那些新文档加入已有bitset，而不是对整个缓存一遍又一遍的重复计算。和系统其他部分一样，过滤器是实时的，我们无需担心缓存过期问题</li></ul><ol><li>独立的过滤器缓存<ul><li>属于一个查询组件的bitsets是独立于它所属搜索请求其他部分的。一旦被缓存，一个查询可以被用作多个搜索请求。bitsets并不依赖于它所存在的查询上下文。这样使得缓存可以加速查询中经常使用的部分，从而降低较少易变的部分所带来的消耗</li><li>同样，如果单个请求重用相同的非评分查询，它缓存的bitset可以被单个搜索里的所有实例所重用</li></ul></li><li>自动缓存行为<ul><li>Elasticsearch会基于使用频次自动缓存查询。如果一个非评分查询在最近的256次查询中被使用过(次数取决于查询类型)，那么这个查询就会作为缓存的候选</li><li>但是，并不是所有的片段都能保证缓存bitset。只有那些文档数量超过10000(或超过总文档数量的3%)才会缓存bitset。因为小的片段可以很快的进行搜索和合并，这里缓存的意义不大</li><li>一旦缓存了，非评分计算的bitset会一直驻留在缓存中直到它被剔除。剔除规则是基于LRU的：一旦缓存满了，最近最少使用的过滤器会被剔除</li></ul></li></ol><h3 id="十二、全文搜索"><a href="#十二、全文搜索" class="headerlink" title="十二、全文搜索"></a>十二、全文搜索</h3><h4 id="1-全文搜索两个重要方面"><a href="#1-全文搜索两个重要方面" class="headerlink" title="1. 全文搜索两个重要方面"></a>1. 全文搜索两个重要方面</h4><ol><li>相关性(Relevance)<br>它是评价查询与其结果间的相关程度，并根据这种相关程度对结果排名的一种能力，这种计算方式可以是TF/IDF方法、地理位置邻近、模糊相似，或其他的某些算法</li><li>分析(Analysis)<br>它是将文本块转换为有区别的、规范化的token的一个过程，目的是为了创建倒排索引以及查询倒排索引</li></ol><ul><li>一旦谈论相关性或分析这两个方面的问题时，我们所处的语境是关于查询的而不是过滤</li></ul><h4 id="2-基于词项与基于全文"><a href="#2-基于词项与基于全文" class="headerlink" title="2. 基于词项与基于全文"></a>2. 基于词项与基于全文</h4><ol><li>基于词项的查询<br>如<code>term</code>或<code>fuzzy</code>这样的底层查询不需要分析阶段，它们对单个词项进行操作。用<code>term</code>查询词项<code>Foo</code>只要在倒排索引中查找准确词项，并且用TF/IDF算法为每个包含该词项的文档计算相关度评分<code>_score</code></li><li>基于全文的查询<br>像<code>match</code>或<code>query_string</code>这样的查询是高层查询，它们了解字段映射的信息<ul><li>如果查询日期(date)或整数(integer)字段，它们会将查询字符串分别作为日期或整数对待</li><li>如果查询一个(not_analyzed)未分析的精确值字符串字段，它们会将整个查询字符串作为单个词项对待</li><li>但如果要查询一个(analyzed)已分析的全文字段，它们会先将查询字符串传递到一个合适的分析器，然后生成一个供查询的词项列表</li></ul></li></ol><ul><li>一旦组成了词项列表，这个查询会对每个词项逐一执行底层的查询，再将结果合并，然后为每个文档生成一个最终的相关度评分</li><li>当我们想要查询一个具有精确值的<code>not_analyzed</code>未分析字段之前，需要考虑，是否真的采用评分查询，或者非评分查询会更好</li><li>单词项查询通常可以用是、非这种二元问题表示，所以更适合用过滤，而且这样做可以有效利用缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123; &quot;gender&quot;: &quot;female&quot; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-匹配查询"><a href="#3-匹配查询" class="headerlink" title="3. 匹配查询"></a>3. 匹配查询</h4><ol><li><p>索引一些数据(只设置一个主分片，防止在数据量少的时候发生相关性破坏)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line"></span><br><span class="line">PUT /my_index</span><br><span class="line">&#123; &quot;settings&quot;: &#123; &quot;number_of_shards&quot;: 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">POST /my_index/my_type/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 1 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 2 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox jumps over the lazy dog&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 3 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;The quick brown fox jumps over the quick dog&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_id&quot;: 4 &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;Brown fox brown dog&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p>单个词查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;QUICK!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>Elasticsearch执行上面这个<code>match</code>查询的步骤是<ol><li>检查字段类型<br>标题<code>title</code>字段是一个<code>string</code>类型(analyzed)已分析的全文字段，这意味着查询字符串本身也应该被分析</li><li>分析查询字符串<br>将查询的字符串<code>QUICK!</code>传入标准分析器中，输出的结果是单个项<code>quick</code>。因为只有一个单词项，所以<code>match</code>查询执行的是单个底层<code>term</code>查询</li><li>查找匹配文档<br>用<code>term</code>查询在倒排索引中查找<code>quick</code>然后获取一组包含该项的文档，本例的结果是文档：1、2和3</li><li>为每个文档评分<br>用<code>term</code>查询计算每个文档相关度评分<code>_score</code>，这是种将词频(词quick在相关文档的title字段中出现的频率)和反向文档频率(词quick在所有文档的title字段中出现的频率)，以及字段的长度(即字段越短相关度越高)相结合的计算方式</li></ol></li></ul><h4 id="4-多词查询"><a href="#4-多词查询" class="headerlink" title="4. 多词查询"></a>4. 多词查询</h4><ol><li><p><code>match</code>多词查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &quot;BROWN DOG!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>提高精度<br><code>match</code>查询还可以接受<code>operator</code>操作符作为输入参数，默认情况下该操作符是<code>or</code>。我们可以将它修改成<code>and</code>让所有指定词项都必须匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:    &quot;BROWN DOG!&quot;,</span><br><span class="line">        &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>控制精度<br><code>match</code>查询支持<code>minimum_should_match</code>最小匹配参数，可以指定必须匹配的词项数。可以将其设置为某个具体数字，更常用的做法是将其设置为一个百分数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;query&quot;:                &quot;quick brown dog&quot;,</span><br><span class="line">        &quot;minimum_should_match&quot;: &quot;75%&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-组合查询"><a href="#5-组合查询" class="headerlink" title="5. 组合查询"></a>5. 组合查询</h4><ul><li><p>在组合过滤器中，<code>bool</code>过滤器通过<code>and</code>、<code>or</code>和<code>not</code>逻辑组合将多个过滤器进行组合。在查询中，<code>bool</code>查询有类似的功能</p></li><li><p>与过滤器一样，<code>bool</code>查询也可以接受<code>must</code>、<code>must_not</code>和<code>should</code>参数下的多个查询语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;:     &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;quick&quot; &#125;&#125;,</span><br><span class="line">      &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;lazy&quot;  &#125;&#125;,</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">                  &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">                  &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;dog&quot;   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>评分计算</p><ul><li><code>bool</code>查询会为每个文档计算相关度评分<code>_score</code>，再将所有匹配的<code>must</code>和<code>should</code>语句的分数<code>_score</code>求和，最后除以<code>must</code>和<code>should</code>语句的总数</li><li><code>must_not</code>语句不会影响评分，它的作用只是将不相关的文档排除</li><li>默认情况下，没有<code>should</code>语句是必须匹配的。只有一个例外，那就是当没有<code>must</code>语句的时候，至少有一个<code>should</code>语句必须匹配</li></ul></li><li><p>控制精度<br>通过<code>minimum_should_match</code>参数控制需要匹配的<code>should</code>语句的数量，它既可以是一个绝对的数字，又可以是个百分比</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;fox&quot;   &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;dog&quot;   &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot;: 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-如何使用布尔匹配"><a href="#6-如何使用布尔匹配" class="headerlink" title="6. 如何使用布尔匹配"></a>6. 如何使用布尔匹配</h4><ul><li>多词<code>match</code>查询只是简单地将生成的<code>term</code>查询包裹在一个<code>bool</code>查询中</li></ul><ol><li><p>使用默认的<code>or</code>操作符，每个<code>term</code>查询都被当作<code>should</code>语句，这样就要求必须至少匹配一条语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;match&quot;: &#123; &quot;title&quot;: &quot;brown fox&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;fox&quot;   &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>and</code>操作符，所有的<code>term</code>查询都被当作<code>must</code>语句，所以所有(all)语句都必须匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:    &quot;brown fox&quot;,</span><br><span class="line">      &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;must&quot;: [</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;fox&quot;   &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果指定参数<code>minimum_should_match</code>，它可以通过<code>bool</code>查询直接传递，使以下两个查询等价</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &#123;</span><br><span class="line">      &quot;query&quot;:                &quot;quick brown fox&quot;,</span><br><span class="line">      &quot;minimum_should_match&quot;: &quot;75%&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;brown&quot; &#125;&#125;,</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;fox&quot;   &#125;&#125;,</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;title&quot;: &quot;quick&quot; &#125;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum_should_match&quot;: 2</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>通常将这些查询用<code>match</code>查询来表示，但是如果了解<code>match</code>内部的工作原理，就能根据自己的需要来控制查询过程。有些时候单个<code>match</code>查询无法满足需求，比如为某些查询条件分配更高的权重</li></ul><h4 id="7-查询语句提升权重"><a href="#7-查询语句提升权重" class="headerlink" title="7. 查询语句提升权重"></a>7. 查询语句提升权重</h4><ol><li><p><code>bool</code>查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:    &quot;full text search&quot;,</span><br><span class="line">            &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Elasticsearch&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;Lucene&quot;        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>让包含<code>Lucene</code>的有更高的权重，并且包含<code>Elasticsearch</code>的语句比<code>Lucene</code>的权重更高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &#123;</span><br><span class="line">            &quot;query&quot;:    &quot;full text search&quot;,</span><br><span class="line">            &quot;operator&quot;: &quot;and&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Elasticsearch&quot;,</span><br><span class="line">            &quot;boost&quot;: 3</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123;</span><br><span class="line">          &quot;content&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &quot;Lucene&quot;,</span><br><span class="line">            &quot;boost&quot;: 2</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>boost</code>参数被用来提升一个语句的相对权重(<code>boost</code>值大于1)或降低相对权重(<code>boost</code>值处于0到1之间)，但是这种提升或降低并不是线性的，如果一个<code>boost</code>值为2，并不能获得两倍的评分<code>_score</code></p></li><li><p>如果不基于TF/IDF要实现自己的评分模型，我们就需要对权重提升的过程能有更多控制，可以使用<code>function_score</code>查询操纵一个文档的权重提升方式而跳过归一化这一步骤</p></li></ol><h4 id="8-控制分析"><a href="#8-控制分析" class="headerlink" title="8. 控制分析"></a>8. 控制分析</h4><ul><li><p>查询只能查找倒排索引表中真实存在的项，所以保证文档在索引时与查询字符串在搜索时应用相同的分析过程非常重要，这样查询的项才能够匹配倒排索引中的项</p></li><li><p>为<code>my_index</code>新增一个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_type&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;english_title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;:     &quot;string&quot;,</span><br><span class="line">        &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过使用<code>analyze</code>API来分析单词<code>Foxes</code>，进而比较<code>english_title</code>字段和<code>title</code>字段在索引时的分析结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;my_type.title&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Foxes&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;my_type.english_title&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Foxes&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以通过<code>validate-query</code>API查看这个行为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;title&quot;:         &quot;Foxes&quot;&#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123; &quot;english_title&quot;: &quot;Foxes&quot;&#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认分析器</p><ul><li>Elasticsearch会按照以下顺序依次处理，直到它找到能够使用的分析器，索引时的顺序如下<ol><li>字段映射里定义的<code>analyzer</code></li><li>索引设置中名为<code>default</code>的分析器</li><li>默认为<code>standard</code>标准分析器</li></ol></li><li>在搜索时，顺序有些许不同<ol><li>查询自己定义的<code>analyzer</code></li><li>字段映射里定义的<code>analyzer</code></li><li>索引设置中名为<code>default</code>的分析器</li><li>默认为<code>standard</code>标准分析器</li></ol></li><li>考虑额外参数，一个搜索时的完整顺序会是下面这样<ol><li>查询自己定义的<code>analyzer</code></li><li>字段映射里定义的<code>search_analyzer</code></li><li>字段映射里定义的<code>analyzer</code></li><li>索引设置中名为<code>default_search</code>的分析器</li><li>索引设置中名为<code>default</code>的分析器</li><li>默认为<code>standard</code>标准分析器</li></ol></li></ul></li><li><p>分析器配置实践  </p><ul><li>多数字符串字段都是<code>not_analyzed</code>精确值字段，比如标签(tag)或枚举(enum)，而且更多的全文字段会使用默认的<code>standard</code>分析器或<code>english</code>或其他某种语言的分析器</li><li>这样只需要为少数一两个字段指定自定义分析：或许标题<code>title</code>字段需要以支持输入即查找(find-as-you-type)的方式进行索引</li><li>可以在索引级别设置中，为绝大部分的字段设置你想指定的<code>default</code>默认分析器。然后在字段级别设置中，对某一两个字段配置需要指定的分析器</li></ul></li></ul><h4 id="9-被破坏的相关度！"><a href="#9-被破坏的相关度！" class="headerlink" title="9. 被破坏的相关度！"></a>9. 被破坏的相关度！</h4><ul><li>由于性能原因，Elasticsearch不会计算索引内所有文档的IDF。相反，每个分片会根据该分片内的所有文档计算一个本地IDF</li><li>因为文档是均匀分布存储的，两个分片的IDF是相同的。如果数据在一个分片里非常普通(所以不那么重要)，但是在另一个分片里非常出现很少(所以会显得更重要)。这些IDF之间的差异会导致不正确的结果</li><li>在实际应用中，这并不是一个问题，本地和全局的IDF的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的IDF会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少</li><li>数据量少的测试环境，可以通过两种方式解决这个问题<ol><li>只在主分片上创建索引，如果只有一个主分片，那么本地的IDF就是全局的IDF</li><li>在搜索请求后添加<code>?search_type=dfs_query_then_fetch</code>，<code>dfs</code>是指分布式频率搜索，它告诉Elasticsearch先分别获得每个分片本地的IDF，然后根据结果再计算整个索引的全局IDF</li></ol></li><li>不要在生产环境上使用<code>dfs_query_then_fetch</code>。完全没有必要，只要有足够的数据就能保证词频是均匀分布的。没有理由给每个查询额外加上DFS这步</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch笔记（四）&quot;&gt;&lt;a href=&quot;#Elasticsearch笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch笔记（四）&quot;&gt;&lt;/a&gt;Elasticsearch笔记（四）&lt;/h2&gt;&lt;h3 id=&quot;十
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="database" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/"/>
    
      <category term="elasticsearch" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://huangdu.work/tags/elasticsearch/"/>
    
      <category term="非关系型数据库" scheme="https://huangdu.work/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记（三）</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/database/elasticsearch/elasticsearch%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://huangdu.work/笔记/database/elasticsearch/elasticsearch笔记（三）/</id>
    <published>2020-02-03T16:00:00.000Z</published>
    <updated>2020-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch笔记（三）"><a href="#Elasticsearch笔记（三）" class="headerlink" title="Elasticsearch笔记（三）"></a>Elasticsearch笔记（三）</h2><h3 id="九、索引管理"><a href="#九、索引管理" class="headerlink" title="九、索引管理"></a>九、索引管理</h3><h4 id="1-创建删除索引"><a href="#1-创建删除索引" class="headerlink" title="1. 创建删除索引"></a>1. 创建删除索引</h4><ol><li><p>创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123; ... any settings ... &#125;,</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;type_one&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">    &quot;type_two&quot;: &#123; ... any mappings ... &#125;,</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>可以通过在config/elasticsearch.yml中添加下面的配置来防止自动创建索引<code>action.auto_create_index: false</code></li></ul></li><li><p>删除索引</p><ul><li>使用以下的请求来删除索引<code>DELETE /my_index</code></li><li>也可以用下面的方式删除多个索引<code>DELETE /index_one,index_two</code> <code>DELETE /index_*</code></li><li>甚至可以删除所有索引<code>DELETE /_all</code></li></ul></li></ol><h4 id="2-索引设置"><a href="#2-索引设置" class="headerlink" title="2. 索引设置"></a>2. 索引设置</h4><ol><li><p>可以创建只有一个主分片，没有复制分片的小索引(<code>number_of_shards</code>定义一个索引的主分片个数，默认值是<code>5</code>。这个配置在索引创建后不能修改)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_temp_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;number_of_shards&quot; : 1,</span><br><span class="line">    &quot;number_of_replicas&quot; : 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，我们可以用update-index-settings API动态修改复制分片个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_temp_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;number_of_replicas&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-配置分析器"><a href="#3-配置分析器" class="headerlink" title="3. 配置分析器"></a>3. 配置分析器</h4><ol><li><p>第三个重要的索引设置是<code>analysis</code>部分，用来配置已存在的分析器或创建自定义分析器来定制化你的索引</p></li><li><p><code>standard</code>分析器是用于全文字段的默认分析器，对于大部分西方语系来说是一个不错的选择。它考虑了以下几点</p><ul><li><code>standard</code>分词器，在词层级上分割输入的文本</li><li><code>standard</code>表征过滤器，被设计用来整理分词器触发的所有表征(但是目前什么都没做)</li><li><code>lowercase</code>表征过滤器，将所有表征转换为小写</li><li><code>stop</code>表征过滤器，删除所有可能会造成搜索歧义的停用词，如<code>a</code> <code>the</code> <code>and</code> <code>is</code>(停用词过滤器默认是被禁用的)</li></ul></li><li><p>创建一个基于<code>standard</code>分析器的自定义分析器，并且设置<code>stopwords</code>参数可以提供一个停用词列表，或者使用一个特定语言的预定停用词列表</p></li><li><p>在下面的例子中，我们创建了一个新的分析器，叫做<code>es_std</code>，并使用预定义的西班牙语停用词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;analyzer&quot;: &#123;</span><br><span class="line">        &quot;es_std&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;standard&quot;,</span><br><span class="line">          &quot;stopwords&quot;: &quot;_spanish_&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>es_std</code>分析器不是全局的，它仅仅存在于我们定义的<code>spanish_docs</code>索引中。为了用analyze API来测试它，我们需要使用特定的索引名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /spanish_docs/_analyze?analyzer=es_std</span><br><span class="line">El veloz zorro marrón</span><br></pre></td></tr></table></figure></li><li><p>下面简化的结果中显示停用词<code>El</code>被正确的删除了  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123; &quot;token&quot; : &quot;veloz&quot;, &quot;position&quot; : 2 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; : &quot;zorro&quot;, &quot;position&quot; : 3 &#125;,</span><br><span class="line">    &#123; &quot;token&quot; : &quot;marrón&quot;, &quot;position&quot; : 4 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="4-自定义分析器"><a href="#4-自定义分析器" class="headerlink" title="4. 自定义分析器"></a>4. 自定义分析器</h4><ol><li><p>分析器是三个顺序执行的组件的结合</p><ol><li>字符过滤器(char_filter)：<ul><li><code>html_strip</code>字符过滤器可以删除所有的HTML标签，并且将HTML实体转换成对应的Unicode字符</li></ul></li><li>分词器(tokenizer)：<ul><li><code>standard</code>分词器将字符串分割成单独的字词，删除大部分标点符号</li><li><code>keyword</code>分词器输出和它接收到的相同的字符串，不做任何分词处理</li><li><code>whitespace</code>分词器只通过空格来分割文本</li><li><code>pattern</code>分词器可以通过正则表达式来分割文本</li></ul></li><li>表征过滤器(filter)：<ul><li><code>lowercase</code>表征过滤器将所有表征转换为小写</li><li><code>stop</code>表征过滤器删除所有可能会造成搜索歧义的停用词，如a the and is</li><li><code>stemmer</code>表征过滤器将单词转化为他们的根形态(root form)</li><li><code>ascii_folding</code>表征过滤器会删除变音符号，比如从très转为tres</li><li><code>ngram</code>和<code>edge_ngram</code>表征过滤器可以让表征更适合特殊匹配情况或自动完成</li></ul></li></ol></li><li><p>创建自定义分析器的格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;char_filter&quot;: &#123; ... custom character filters ... &#125;,</span><br><span class="line">      &quot;tokenizer&quot;: &#123; ... custom tokenizers ... &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123; ... custom token filters ... &#125;,</span><br><span class="line">      &quot;analyzer&quot;: &#123; ... custom analyzers ... &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建自定义字符过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;char_filter&quot;: &#123;</span><br><span class="line">  &quot;&amp;_to_and&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">    &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建自定义表征过滤器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;filter&quot;: &#123;</span><br><span class="line">  &quot;my_stopwords&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;stop&quot;,</span><br><span class="line">    &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>组合成分析器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;analyzer&quot;: &#123;</span><br><span class="line">  &quot;my_analyzer&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">    &quot;char_filter&quot;: [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],</span><br><span class="line">    &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">    &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用下面的方式可以将以上请求合并成一条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;analysis&quot;: &#123;</span><br><span class="line">      &quot;char_filter&quot;: &#123;</span><br><span class="line">        &quot;&amp;_to_and&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;mapping&quot;,</span><br><span class="line">          &quot;mappings&quot;: [ &quot;&amp;=&gt; and &quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;my_stopwords&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;stop&quot;,</span><br><span class="line">          &quot;stopwords&quot;: [ &quot;the&quot;, &quot;a&quot; ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;analyzer&quot;: &#123;</span><br><span class="line">        &quot;my_analyzer&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">          &quot;char_filter&quot;: [ &quot;html_strip&quot;, &quot;&amp;_to_and&quot; ],</span><br><span class="line">          &quot;tokenizer&quot;: &quot;standard&quot;,</span><br><span class="line">          &quot;filter&quot;: [ &quot;lowercase&quot;, &quot;my_stopwords&quot; ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试分析器<code>GET /my_index/_analyze?analyzer=my_analyzer  The quick &amp; brown fox</code></p></li><li><p>使用分析器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;title&quot;: &#123;</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;analyzer&quot;: &quot;my_analyzer&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-类型和映射"><a href="#5-类型和映射" class="headerlink" title="5. 类型和映射"></a>5. 类型和映射</h4><ol><li><p>Lucene中一个文档由一组简单的键值对组成，一个字段至少需要有一个值，但是任何字段都可以有多个值。类似的，一个单独的字符串可能在分析过程中被转换成多个值。Lucene不关心这些值是字符串，数字或日期，所有的值都被当成不透明字节</p></li><li><p>Elasticsearch类型是在这个简单基础上实现的。一个索引可能包含多个类型，每个类型有各自的映射和文档，保存在同一个索引中</p><ul><li>因为Lucene没有文档类型的概念，每个文档的类型名被储存在一个叫<code>_type</code>的元数据字段上。当我们搜索一种特殊类型的文档时，Elasticsearch简单的通过<code>_type</code>字段来过滤出这些文档</li><li>Lucene同样没有映射的概念。映射是Elasticsearch将复杂JSON文档映射成Lucene需要的扁平化数据的方式</li></ul></li><li><p>预防类型陷阱</p><ul><li><p>想象一下我们的索引中有两种类型：blog_en表示英语版的博客，blog_es表示西班牙语版的博客。两种类型都有title字段，但是其中一种类型使用english分析器，另一种使用spanish分析器</p></li><li><p>我们在两种类型中搜索title字段，首先需要分析查询语句，Elasticsearch会采用第一个被找到的title字段使用的分析器，这对于这个字段的文档来说是正确的，但对另一个来说却是错误的</p></li><li><p>我们可以通过给字段取不同的名字来避免这种错误。比如，用title_en和title_es。或者在查询中明确包含各自的类型名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;multi_match&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &quot;The quick brown fox&quot;,</span><br><span class="line">      &quot;fields&quot;: [ &quot;blog_en.title&quot;, &quot;blog_es.title&quot; ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为了保证你不会遇到这些冲突，建议在同一个索引的每一个类型中，确保用同样的方式映射同名的字段</p></li></ul></li></ol><h4 id="6-根对象"><a href="#6-根对象" class="headerlink" title="6. 根对象"></a>6. 根对象</h4><ol><li>映射的最高一层被称为根对象，它可能包含下面几项<ul><li>一个<code>properties</code>节点，列出了文档中可能包含的每个字段的映射</li><li>多个元数据字段，每一个都以下划线开头，例如<code>_type</code> <code>_id</code>和<code>_source</code></li><li>设置项，控制如何动态处理新的字段，例如<code>analyzer</code> <code>dynamic_date_formats</code>和<code>dynamic_templates</code></li><li>其他设置，可以同时应用在根对象和其他<code>object</code>类型的字段上，例如<code>enabled</code> <code>dynamic</code>和<code>include_in_all</code></li></ul></li><li>文档字段和属性的三个最重要的设置<ul><li><code>type</code>：字段的数据类型，例如string和date</li><li><code>index</code>：字段是否应当被当成全文来搜索(analyzed)，或被当成一个准确的值(not_analyzed)，还是完全不可被搜索(no)</li><li><code>analyzer</code>：确定在索引和或搜索时全文字段使用的分析器</li></ul></li></ol><h4 id="7-元数据中的source字段"><a href="#7-元数据中的source字段" class="headerlink" title="7. 元数据中的source字段"></a>7. 元数据中的source字段</h4><ol><li><p>默认情况下，Elasticsearch用JSON字符串来表示文档主体保存在<code>_source</code>字段中。像其他保存的字段一样，<code>_source</code>字段也会在写入硬盘前压缩</p></li><li><p>可以用下面的映射禁用<code>_source</code>字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;_source&quot;: &#123;</span><br><span class="line">      &quot;enabled&quot;: false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在搜索请求中你可以通过限定<code>_source</code>字段来请求指定字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;_source&quot;: [ &quot;title&quot;, &quot;created&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Elasticsearch中，单独设置储存字段不是一个好做法。完整的文档已经被保存在<code>_source</code>字段中。通常最好的办法会是使用<code>_source</code>参数来过滤你需要的字段</p></li></ol><h4 id="8-元数据中的all字段"><a href="#8-元数据中的all字段" class="headerlink" title="8. 元数据中的all字段"></a>8. 元数据中的all字段</h4><ol><li><p>如果你决定不再使用<code>_all</code>字段，你可以通过下面的映射禁用它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_type&quot;: &#123;</span><br><span class="line">    &quot;_all&quot;: &#123; &quot;enabled&quot;: false &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<code>include_in_all</code>选项可以控制字段是否要被包含在<code>_all</code>字段中，默认值是<code>true</code>。在一个对象上设置<code>include_in_all</code>可以修改这个对象所有字段的默认行为</p></li><li><p>你可能想要保留<code>_all</code>字段来查询所有特定的全文字段。相对于完全禁用<code>_all</code>字段，你可以先默认禁用<code>include_in_all</code>选项，而选定字段上启用<code>include_in_all</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_type&quot;: &#123;</span><br><span class="line">    &quot;include_in_all&quot;: false,</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">        &quot;include_in_all&quot;: true</span><br><span class="line">      &#125;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>谨记<code>_all</code>字段仅仅是一个经过分析的string字段。它使用默认的分析器来分析它的值，而不管这值本来所在的字段指定的分析器。而且像所有string类型字段一样，你可以配置<code>_all</code>字段使用的分析器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  &quot;my_type&quot;: &#123;</span><br><span class="line">    &quot;_all&quot;: &#123; &quot;analyzer&quot;: &quot;whitespace&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="9-元数据中的id字段"><a href="#9-元数据中的id字段" class="headerlink" title="9. 元数据中的id字段"></a>9. 元数据中的id字段</h4><ol><li><p>文档唯一标识由四个元数据字段组成</p><ul><li><code>_id</code>：文档的字符串ID</li><li><code>_type</code>：文档的类型名</li><li><code>_index</code>：文档所在的索引</li><li><code>_uid</code>：<code>_type</code>和<code>_id</code>连接成的<code>type#id</code></li></ul></li><li><p><code>_id</code>字段有一个你可能用得到的设置：<code>path</code>设置告诉Elasticsearch它需要从文档本身的哪个字段中生成<code>_id</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;doc_id&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;doc_id&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>虽然这样很方便，但是注意它对<code>bulk</code>请求有个轻微的性能影响。处理请求的节点将不能仅靠解析元数据行来决定将请求分配给哪一个分片，而需要解析整个文档主体</p></li></ol><h4 id="10-动态映射"><a href="#10-动态映射" class="headerlink" title="10. 动态映射"></a>10. 动态映射</h4><ol><li><p>当Elasticsearch遇到一个未知的字段时，它通过动态映射来确定字段的数据类型且自动将该字段加到类型映射中</p></li><li><p>可以通过<code>dynamic</code>设置来控制这些行为，它接受下面几个选项</p><ul><li><code>true</code>：自动添加字段(默认)</li><li><code>false</code>：忽略字段</li><li><code>strict</code>：当遇到未知字段时抛出异常</li></ul></li><li><p><code>dynamic</code>设置可以用在根对象或任何<code>object</code>对象上。你可以将<code>dynamic</code>默认设置为<code>strict</code>，而在特定内部对象上启用它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;dynamic&quot;: &quot;strict&quot;,</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;title&quot;: &#123; &quot;type&quot;: &quot;string&quot;&#125;,</span><br><span class="line">        &quot;stash&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">          &quot;dynamic&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>dynamic</code>设置成<code>false</code>完全不会修改<code>_source</code>字段的内容。<code>_source</code>将仍旧保持你索引时的完整JSON文档。然而，没有被添加到映射的未知字段将不可被搜索</p></li></ol><h4 id="11-自定义动态映射"><a href="#11-自定义动态映射" class="headerlink" title="11. 自定义动态映射"></a>11. 自定义动态映射</h4><ol><li><p>当Elasticsearch遇到一个新的字符串字段时，它会检测这个字段是否包含一个可识别的日期，比如<code>2014-01-01</code>。如果它看起来像一个日期，这个字段会被作为<code>date</code>类型添加，否则，它会被作为<code>string</code>类型添加</p></li><li><p>日期检测可以通过在根对象上设置<code>date_detection</code>为<code>false</code>来关闭</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;date_detection&quot;: false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch判断字符串为日期的规则可以通过<code>dynamic_date_formats</code>配置来修改</p></li><li><p>使用<code>dynamic_templates</code>，你可以完全控制新字段的映射，你设置可以通过字段名或数据类型应用一个完全不同的映射<br>(es:字段名以<code>_es</code>结尾需要使用<code>spanish</code>分析器 en:所有其他字段使用<code>english</code>分析器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;dynamic_templates&quot;: [</span><br><span class="line">        &#123; &quot;es&quot;: &#123;</span><br><span class="line">          &quot;match&quot;: &quot;*_es&quot;,</span><br><span class="line">          &quot;match_mapping_type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;analyzer&quot;: &quot;spanish&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123; &quot;en&quot;: &#123;</span><br><span class="line">          &quot;match&quot;: &quot;*&quot;,</span><br><span class="line">          &quot;match_mapping_type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;mapping&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">            &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>match_mapping_type</code>允许你限制模板只能使用在特定的类型上，就像由标准动态映射规则检测的一样，(例如string和long)</p></li><li><p><code>match</code>参数只匹配字段名，<code>path_match</code>参数则匹配字段在一个对象中的完整路径，所以<code>address.*.name</code>规则将匹配一个这样的字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;address&quot;: &#123;</span><br><span class="line">    &quot;city&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;New York&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>unmatch</code>和<code>path_unmatch</code>规则将用于排除未被匹配的字段</p></li></ol><h4 id="12-默认映射"><a href="#12-默认映射" class="headerlink" title="12. 默认映射"></a>12. 默认映射</h4><ol><li><p>通常，一个索引中的所有类型具有共享的字段和设置。用<code>_default_</code>映射来指定公用设置会更加方便，而不是每次创建新的类型时重复操作</p></li><li><p><code>_default</code>映射像新类型的模板。所有在<code>_default_</code>映射 之后的类型将包含所有的默认设置，除非在自己的类型映射中明确覆盖这些配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;_default_&quot;: &#123;</span><br><span class="line">      &quot;_all&quot;: &#123; &quot;enabled&quot;: false &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;blog&quot;: &#123;</span><br><span class="line">      &quot;_all&quot;: &#123; &quot;enabled&quot;: true &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>_default_</code>映射也是定义索引级别的动态模板的好地方</p></li></ol><h4 id="13-重新索引数据"><a href="#13-重新索引数据" class="headerlink" title="13. 重新索引数据"></a>13. 重新索引数据</h4><ol><li>虽然你可以给索引添加新的类型，或给类型添加新的字段，但是你不能添加新的分析器或修改已有字段。假如你这样做，已被索引的数据会变得不正确而你的搜索也不会正常工作</li><li>修改在已存在的数据最简单的方法是重新索引：创建一个新配置好的索引，然后将所有的文档从旧的索引复制到新的上</li><li><code>_source</code>字段的一个最大的好处是你已经在Elasticsearch中有了完整的文档，你不再需要从数据库中重建你的索引，这样通常会比较慢</li><li>为了更高效的索引旧索引中的文档，使用<code>scan-scoll</code>来批量读取旧索引的文档，然后将通过<code>bulk API</code>来将它们推送给新的索引<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;date&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: &quot;2014-01-01&quot;,</span><br><span class="line">        &quot;lt&quot;: &quot;2014-02-01&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;size&quot;: 1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="14-索引别名"><a href="#14-索引别名" class="headerlink" title="14. 索引别名"></a>14. 索引别名</h4><ol><li><p>前面提到的重新索引过程中的问题是必须更新你的应用，来使用另一个索引名。索引别名正是用来解决这个问题的</p></li><li><p>有两种管理别名的途径：<code>_alias</code>用于单个操作，<code>_aliases</code>用于原子化多个操作</p></li><li><p>创建一个索引<code>my_index_v1</code>，然后将别名<code>my_index</code>指向它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index_v1</span><br><span class="line">PUT /my_index_v1/_alias/my_index</span><br></pre></td></tr></table></figure></li><li><p>检测这个别名指向哪个索引，或哪些别名指向这个索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /*/_alias/my_index</span><br><span class="line">GET /my_index_v1/_alias/*</span><br></pre></td></tr></table></figure></li><li><p>两者都将返回下列值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;my_index_v1&quot; : &#123;</span><br><span class="line">    &quot;aliases&quot; : &#123;</span><br><span class="line">      &quot;my_index&quot; : &#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后，我们决定修改索引中一个字段的映射。当然我们不能修改现存的映射，索引我们需要重新索引数据。首先，我们创建有新的映射的索引<code>my_index_v2</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index_v2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;my_type&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;tags&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">          &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们从将数据从<code>my_index_v1</code>迁移到<code>my_index_v2</code>(原子化操作)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123; &quot;remove&quot;: &#123; &quot;index&quot;: &quot;my_index_v1&quot;, &quot;alias&quot;: &quot;my_index&quot; &#125;&#125;,</span><br><span class="line">    &#123; &quot;add&quot;: &#123; &quot;index&quot;: &quot;my_index_v2&quot;, &quot;alias&quot;: &quot;my_index&quot; &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在应用中使用别名而不是索引。然后你就可以在任何时候重建索引。别名的开销很小，应当广泛使用</p></li></ol><h3 id="十、分片内部原理"><a href="#十、分片内部原理" class="headerlink" title="十、分片内部原理"></a>十、分片内部原理</h3><h4 id="1-使文本可被搜索"><a href="#1-使文本可被搜索" class="headerlink" title="1. 使文本可被搜索"></a>1. 使文本可被搜索</h4><ul><li>传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多个值的能力(单词)</li><li>最好的支持一个字段多个值需求的数据结构是倒排索引(inverted-index)。倒排索引包含一个有序列表，列表包含所有文档出现过的不重复词项，对于每一个词项，包含了它所有曾出现过文档的列表</li><li>早期的全文检索会为整个文档集合建立一个很大的倒排索引并将其写入到磁盘。一旦新的索引就绪，旧的就会被其替换，这样最近的变化便可以被检索到</li></ul><h4 id="2-不变性"><a href="#2-不变性" class="headerlink" title="2. 不变性"></a>2. 不变性</h4><ul><li>倒排索引被写入磁盘后是不可改变的，它永远不会修改，不变性有重要的价值<ol><li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题</li><li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升</li><li>其它缓存(像filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化</li><li>写入单个大的倒排索引允许数据被压缩，减少磁盘I/O和需要被缓存到内存的索引的使用量</li></ol></li><li>一个不变的索引也有不好的地方。如果你需要让一个新的文档可被搜索，你需要重建整个索引。这要么对一个索引所能包含的数据量造成了很大的限制，要么对索引可被更新的频率造成了很大的限制</li></ul><h4 id="3-动态更新索引"><a href="#3-动态更新索引" class="headerlink" title="3. 动态更新索引"></a>3. 动态更新索引</h4><ul><li>通过增加新的补充索引来反映新近的修改，而不是直接重写整个倒排索引。每一个倒排索引都会被轮流查询到，从最早的开始，​查询完后再对结果进行合并</li><li>Elasticsearch基于Lucene，一个Lucene索引我们在Elasticsearch称作分片，一个Elasticsearch索引是分片的集合。一个Lucene索引包含一个提交点和三个段，Lucene这个java库引入了按段搜索的概念，每一段本身都是一个倒排索引，但索引在Lucene中除表示所有段的集合外，还增加了一个列出了所有已知段的文件(提交点)</li><li>当一个查询被触发，所有已知的段按顺序被查询。词项统计会对所有段的结果进行聚合，以保证每个词和每个文档的关联都被准确计算。这种方式可以用相对较低的成本将新文档添加到索引</li><li>段是不可改变的，所以既不能从把文档从旧的段中移除，也不能修改旧的段来进行反映文档的更新。取而代之的是，每个提交点会包含一个<code>.del</code>文件，文件中会列出这些被删除文档的段信息</li><li>当一个文档被删除或被更新时(相当于旧版本文档被删除)实际上只是在<code>.del</code>文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除(在后续操作中被标记删除的文档最终会被系统移除)</li></ul><h4 id="4-近实时搜索"><a href="#4-近实时搜索" class="headerlink" title="4. 近实时搜索"></a>4. 近实时搜索</h4><ul><li>新文档在几分钟之内即可被检索，但这样还是不够快，磁盘在这里成为了瓶颈，我们需要的是一个更轻量的方式来使一个文档可被搜索</li><li>在Elasticsearch和磁盘之间是文件系统缓存。在内存索引缓冲区(在内存缓冲区中包含了新文档的Lucene索引)中的文档会被写入到一个新的段中(缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交)</li><li>新段会被先写入到文件系统缓存(这一步代价会比较低)，稍后再被刷新到磁盘(​这一步代价比较高)。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了</li><li>在Elasticsearch中，写入和打开一个新段的轻量的过程叫做<code>refresh</code>。默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说Elasticsearch是近实时搜索(文档的变化并不是立即对搜索可见，但会在一秒之内变为可见)</li><li>尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。相反，你的应用需要意识到Elasticsearch的近实时的性质，并接受它的不足</li></ul><ol><li><p>手动刷新所有的索引 <code>POST /_refresh</code></p></li><li><p>手动刷新<code>blogs</code>索引 <code>POST /blogs/_refresh</code></p></li><li><p>设置自动刷新的时间间隔(<code>refresh_interval</code>需要一个持续时间值，例如<code>1s</code>或<code>2m</code>。一个绝对值<code>1</code>表示的是1毫秒，无疑会使你的集群陷入瘫痪)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot;: &#123;</span><br><span class="line">    &quot;refresh_interval&quot;: &quot;30s&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关闭自动刷新(在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来)  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; &quot;refresh_interval&quot;: -1 &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="5-持久化变更"><a href="#5-持久化变更" class="headerlink" title="5. 持久化变更"></a>5. 持久化变更</h4><ul><li>如果没有用fsync把数据从文件系统缓存刷(flush)到硬盘，我们不能保证数据在断电甚至是程序正常退出之后依然存在。为了保证Elasticsearch的可靠性，需要确保数据变化被持久化到磁盘</li><li>即使通过每秒刷新(refresh)实现了近实时搜索，我们仍然需要经常进行完整提交来确保能从失败中恢复。我们也不希望丢失掉两次提交之间发生变化的文档数据</li><li>Elasticsearch增加了一个translog，或者叫事务日志，在每一次对Elasticsearch进行操作时均进行了日志记录。通过translog，整个流程看起来是下面这样：</li></ul><ol><li>一个文档被索引之后，就会被添加到内存缓冲区，并且追加到了translog</li><li>刷新(refresh)使分片处于刷新(refresh)完成后，缓存被清空，但是事务日志不会</li><li>这个进程继续工作，更多的文档被添加到内存缓冲区和追加到事务日志</li><li>分片每30分钟被自动刷新(flush)，或者在translog太大的时候也会刷新。一个新的translog被创建，并且一个全量提交被执行</li></ol><ul><li>translog提供所有还没有被刷到磁盘的操作的一个持久化纪录。当Elasticsearch启动的时候，它会从磁盘中使用最后一个提交点去恢复已知的段，并且会重放translog中所有在最后一次提交后发生的变更操作</li><li>translog也被用来提供实时CRUD。当你试着通过ID查询、更新、删除一个文档，它会在尝试从相应的段中检索之前，首先检查translog任何最近的变更。这意味着它总是能够实时地获取到文档的最新版本</li></ul><ol><li>手动刷新<code>blogs</code>索引 <code>POST /blogs/_flush</code></li><li>手动刷新所有索引，并在其完成后返回结果 <code>POST /_flush?wait_for_ongoing</code></li><li>设置translog的fsync间隔(提升一些性能，但是有丢失几秒数据的风险)(默认每次写请求完成后都fsync，默认参数<code>&quot;index.translog.durability&quot;: &quot;request&quot;</code>)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;index.translog.durability&quot;: &quot;async&quot;,</span><br><span class="line">  &quot;index.translog.sync_interval&quot;: &quot;5s&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-段合并"><a href="#6-段合并" class="headerlink" title="6. 段合并"></a>6. 段合并</h4><ul><li>由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦(每一个段都会消耗文件句柄、内存和cpu运行周期)，每个搜索请求都必须轮流检查每个段，段越多，搜索也就越慢</li><li>Elasticsearch通过在后台进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档(或被更新文档的旧版本)不会被拷贝到新的大段中</li><li>启动段合并不需要你做任何事，进行索引和搜索时会自动进行。合并大的段需要消耗大量的I/O和CPU资源，如果任其发展会影响搜索性能。Elasticsearch在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行</li><li>手动合并索引为一个段(可能会消耗很多资源使节点不能正常使用) <code>POST /logstash-2014-10/_optimize?max_num_segments=1</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch笔记（三）&quot;&gt;&lt;a href=&quot;#Elasticsearch笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch笔记（三）&quot;&gt;&lt;/a&gt;Elasticsearch笔记（三）&lt;/h2&gt;&lt;h3 id=&quot;九
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="database" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/"/>
    
      <category term="elasticsearch" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://huangdu.work/tags/elasticsearch/"/>
    
      <category term="非关系型数据库" scheme="https://huangdu.work/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记（二）</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/database/elasticsearch/elasticsearch%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://huangdu.work/笔记/database/elasticsearch/elasticsearch笔记（二）/</id>
    <published>2020-01-04T16:00:00.000Z</published>
    <updated>2020-02-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch笔记（二）"><a href="#Elasticsearch笔记（二）" class="headerlink" title="Elasticsearch笔记（二）"></a>Elasticsearch笔记（二）</h2><h3 id="六、请求体查询"><a href="#六、请求体查询" class="headerlink" title="六、请求体查询"></a>六、请求体查询</h3><h4 id="1-请求体查询"><a href="#1-请求体查询" class="headerlink" title="1. 请求体查询"></a>1. 请求体查询</h4><ul><li><p>简单查询语句(lite)是一种有效的命令行adhoc查询。更复杂的查询，必须使用请求体查询(request bodysearch )API</p></li><li><p>请求体查询中的空查询</p><ol><li><p>返回索引中所有文档(<code>hits</code>中默认显示10个)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>同字符串查询一样，可以查询一个，多个或<code>_all</code>索引(indices)或类型(types)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /index_2014*/type1,type2/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用<code>from</code>及<code>size</code>参数进行分页</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 30,</span><br><span class="line">  &quot;size&quot;: 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>Elasticsearch的作者们倾向于使用<code>GET</code>提交查询请求，因为他们觉得这个词相比<code>POST</code>来说，能更好的描述这种行为</p></li><li><p>然而，因为携带交互数据的<code>GET</code>请求并不被广泛支持，所以search API同样支持<code>POST</code>请求，这个原理同样应用于其他携带交互数据的GET API请求中。</p></li><li><p>相对于神秘的查询字符串方法，请求体查询允许我们使用结构化查询Query DSL(Query Domain Specific Language)</p></li></ul><h4 id="2-查询表达式"><a href="#2-查询表达式" class="headerlink" title="2. 查询表达式"></a>2. 查询表达式</h4><ul><li><p>结构化查询是一种灵活的，多表现形式的查询语言，Elasticsearch在一个简单的JSON接口中用结构化查询来展现Lucene绝大多数能力</p></li><li><p>使用结构化查询，你需要传递<code>query</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>空查询在功能上等同于使用<code>match_all</code>查询子句，匹配所有的文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询子句一般结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  QUERY_NAME: &#123;</span><br><span class="line">    ARGUMENT: VALUE,</span><br><span class="line">    ARGUMENT: VALUE,...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  QUERY_NAME: &#123;</span><br><span class="line">    FIELD_NAME: &#123;</span><br><span class="line">      ARGUMENT: VALUE,</span><br><span class="line">      ARGUMENT: VALUE,...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询子句示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;interests&quot;: &quot;music&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并多子句</p><ul><li><p>查询子句就像是搭积木一样，可以合并简单的子句为一个复杂的查询语句</p></li><li><p>简单子句(leaf clauses)(比如<code>match</code>子句)用以在将查询字符串与一个字段(或多字段)进行比较</p></li><li><p>复合子句(compound)用以合并其他的子句。例如，<code>bool</code>子句允许你合并其他的合法子句，例<code>must</code> <code>must_not</code> <code>should</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;elasticsearch&quot; &#125;&#125;,</span><br><span class="line">    &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;name&quot;: &quot;mary&quot; &#125;&#125;,</span><br><span class="line">    &quot;should&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;full text&quot; &#125;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复合子句能合并任意其他查询子句，包括其他的复合子句。这就意味着复合子句可以相互嵌套，从而实现非常复杂的逻辑</p></li><li><p>以下实例查询在inbox中未标记spam或星标(starred)中找出包含”business opportunity”的邮件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;email&quot;: &quot;business opportunity&quot; &#125;&#125;,</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;match&quot;: &#123; &quot;starred&quot;: true &#125;&#125;,</span><br><span class="line">      &#123; &quot;bool&quot;: &#123;</span><br><span class="line">        &quot;must&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;,</span><br><span class="line">        &quot;must_not&quot;: &#123; &quot;spam&quot;: true &#125;&#125;</span><br><span class="line">      &#125;&#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;minimum_should_match&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="3-查询与过滤"><a href="#3-查询与过滤" class="headerlink" title="3. 查询与过滤"></a>3. 查询与过滤</h4><ul><li>两种结构化语句：结构化查询(Query DSL)和结构化过滤(Filter DSL)</li><li>过滤语句会询问每个文档的字段值是否包含着特定值</li><li>查询语句会询问每个文档的字段值与特定值的匹配程度如何</li><li>原则上来说，使用查询语句做全文本搜索或其他需要进行相关性评分的时候，剩下的全部用过滤语句</li><li>查询语句和过滤语句可以放在各自的上下文中，在ElasticSearch API中我们会看到许多带有<code>query</code>或<code>filter</code>的语句</li><li>这些语句既可以包含单条<code>query</code>语句，也可以包含一条<code>filter</code>子句。这些语句需要首先创建一个<code>query</code>或<code>filter</code>的上下文关系</li><li>复合查询语句可以加入其他查询子句，复合过滤语句也可以加入其他过滤子句。通常情况下，一条查询语句需要过滤语句的辅助，全文本搜索除外</li><li>查询语句可以包含过滤子句，反之亦然。以便于我们切换<code>query</code>或<code>filter</code>的上下文。这就要求我们在读懂需求的同时构造正确有效的语句</li></ul><h4 id="4-最重要的查询"><a href="#4-最重要的查询" class="headerlink" title="4. 最重要的查询"></a>4. 最重要的查询</h4><ol><li><p><code>term</code>过滤<br><code>term</code>主要用于精确匹配哪些值，比如数字、日期、布尔值或<code>not_analyzed</code>的字符串(未经分析的文本数据类型)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;term&quot;: &#123; &quot;age&quot;: 26 &#125;&#125;</span><br><span class="line">&#123; &quot;term&quot;: &#123; &quot;date&quot;: &quot;2014-09-01&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;term&quot;: &#123; &quot;public&quot;: true &#125;&#125;</span><br><span class="line">&#123; &quot;term&quot;: &#123; &quot;tag&quot;: &quot;full_text&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>terms</code>过滤<br><code>terms</code>跟<code>term</code>有点类似，但<code>terms</code>允许指定多个匹配条件。如果某个字段指定了多个值，那么文档需要一起去做匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;terms&quot;: &#123;</span><br><span class="line">    &quot;tag&quot;: [ &quot;search&quot;, &quot;full_text&quot;, &quot;nosql&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>range</code>过滤<br><code>range</code>过滤允许我们按照指定范围查找一批数据 <code>gt</code>大于 <code>gte</code>大于等于 <code>lt</code>小于 <code>lte</code>小于等于</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;range&quot;: &#123;</span><br><span class="line">    &quot;age&quot;: &#123;</span><br><span class="line">      &quot;gte&quot;: 20,</span><br><span class="line">      &quot;lt&quot;: 30</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>exists</code>和<code>missing</code>过滤<br><code>exists</code>和<code>missing</code>过滤可以用于查找文档中是否包含指定字段或没有某个字段，类似于SQL语句中的<code>IS_NULL</code>条件<br>这两个过滤只是针对已经查出一批数据来，但是想区分出某个字段是否存在的时候使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;exists&quot;: &#123;</span><br><span class="line">    &quot;field&quot;: &quot;title&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bool</code>过滤<br><code>bool</code>过滤可以用来合并多个过滤条件查询结果的布尔逻辑，它包含以下操作符</p><ul><li><code>must</code>多个查询条件的完全匹配，相当于and</li><li><code>must_not</code>多个查询条件的相反匹配，相当于not</li><li><code>should</code>至少有一个查询条件匹配，相当于or</li><li>这些参数可以分别继承一个过滤条件或者一个过滤条件的数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;must&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;,</span><br><span class="line">    &quot;must_not&quot;: &#123; &quot;term&quot;: &#123; &quot;tag&quot;: &quot;spam&quot; &#125;&#125;,</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;starred&quot;: true &#125;&#125;,</span><br><span class="line">      &#123; &quot;term&quot;: &#123; &quot;unread&quot;: true &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>match_all</code>查询<br>使用<code>match_all</code>可以查询到所有文档，是没有查询条件下的默认语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>match</code>查询<br><code>match</code>查询是一个标准查询，不管你需要全文本查询还是精确查询基本上都要用到它<br>做精确匹配搜索时，最好用过滤语句，因为过滤语句可以缓存数据<br>不像在简单搜索中介绍的字符查询，<code>match</code>查询不可以用类似<code>+usid:2 +tweet:search</code>这样的语句。它只能就指定某个确切字段某个确切的值进行搜索，而你要做的就是为它指定正确的字段名以避免语法错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;match&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot;: &quot;About Search&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;age&quot;: 26 &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;date&quot;: &quot;2014-09-01&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;public&quot;: true &#125;&#125;</span><br><span class="line">&#123; &quot;match&quot;: &#123; &quot;tag&quot;: &quot;full_text&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>multi_match</code>查询<br><code>multi_match</code>查询允许你做<code>match</code>查询的基础上同时搜索多个字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;multi_match&quot;: &#123;</span><br><span class="line">    &quot;query&quot;: &quot;full text search&quot;,</span><br><span class="line">    &quot;fields&quot;: [ &quot;title&quot;, &quot;body&quot; ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>bool</code>查询<br><code>bool</code>查询与<code>bool</code>过滤相似，用于合并多个查询子句。不同的是，<code>bool</code>过滤可以直接给出是否匹配成功，而<code>bool</code>查询要计算每一个查询子句的<code>_score</code>(相关性分值) </p><ul><li><code>must</code>查询指定文档一定要被包含</li><li><code>must_not</code>查询指定文档一定不要被包含</li><li><code>should</code>查询指定文档，有则可以为文档相关性加分</li><li>如果<code>bool</code>查询下没有<code>must</code>子句，那至少应该有一个<code>should</code>子句。但是如果有<code>must</code>子句，那么没有<code>should</code>子句也可以进行查询</li><li>以下查询将会找到<code>title</code>字段中包含”how to make millions”，并且<code>tag</code>字段没有被标为spam，如果有标识为”starred”或者发布日期为2014年之前，那么这些匹配的文档将比同类网站等级高<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bool&quot;: &#123;</span><br><span class="line">    &quot;must&quot;: &#123; &quot;match&quot;: &#123; &quot;title&quot;: &quot;how to make millions&quot; &#125;&#125;,</span><br><span class="line">    &quot;must_not&quot;: &#123; &quot;match&quot;: &#123; &quot;tag&quot;: &quot;spam&quot; &#125;&#125;,</span><br><span class="line">    &quot;should&quot;: [</span><br><span class="line">      &#123; &quot;match&quot;: &#123; &quot;tag&quot;: &quot;starred&quot; &#125;&#125;,</span><br><span class="line">      &#123; &quot;range&quot;: &#123; &quot;date&quot;: &#123; &quot;gte&quot;: &quot;2014-01-01&quot; &#125;&#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="5-带过滤的查询语句"><a href="#5-带过滤的查询语句" class="headerlink" title="5. 带过滤的查询语句"></a>5. 带过滤的查询语句</h4><ol><li><p>search API中只能包含<code>query</code>语句，所以我们需要用<code>filtered</code>来同时包含<code>query</code>和<code>filter</code>子句，我们在外层再加入<code>query</code>的上下文关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;filtered&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;email&quot;: &quot;business opportunity&quot; &#125;&#125;,</span><br><span class="line">      &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>query</code>上下文中，如果你只需要一条过滤语句，比如在匹配全部邮件的时候，可以省略<code>query</code>子句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;filtered&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果一条查询语句没有指定查询范围，那么它默认使用<code>match_all</code>查询，所以上面语句的完整形式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;filtered&quot;: &#123;</span><br><span class="line">      &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">      &quot;filter&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>过滤语句中可以使用<code>query</code>查询的方式代替<code>bool</code>过滤子句(我们很少用到的过滤语句中包含查询，保留这种用法只是为了语法的完整性。只有在过滤中用到全文本匹配的时候才会使用这种结构)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;filtered&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: &#123; &quot;term&quot;: &#123; &quot;folder&quot;: &quot;inbox&quot; &#125;&#125;,</span><br><span class="line">          &quot;must_not&quot;: &#123;</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">              &quot;match&quot;: &#123; &quot;email&quot;: &quot;urgent business proposal&quot; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="6-验证查询"><a href="#6-验证查询" class="headerlink" title="6. 验证查询"></a>6. 验证查询</h4><ol><li><p>validate API可以验证一条查询语句是否合法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot; : &#123;</span><br><span class="line">      &quot;match&quot; : &quot;really powerful&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>想知道语句非法的具体错误信息，需要加上<code>explain</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /gb/tweet/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot; : &#123;</span><br><span class="line">      &quot;match&quot; : &quot;really powerful&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="七、排序与相关性"><a href="#七、排序与相关性" class="headerlink" title="七、排序与相关性"></a>七、排序与相关性</h3><h4 id="1-排序方式"><a href="#1-排序方式" class="headerlink" title="1. 排序方式"></a>1. 排序方式</h4><ul><li><p>默认情况下，结果集会按照相关性进行排序(相关性分值会用<code>_score</code>字段来给出一个浮点型的数值，默认情况下，结果集以<code>_score</code>进行倒序排列)</p></li><li><p>过滤语句与<code>_score</code>没有关系，但是有隐含的查询条件<code>match_all</code>为所有的文档的<code>_score</code>设值为1。也就相当于所有的文档相关性是相同的</p></li><li><p>下面例子中，对结果集按照时间排序</p><ol><li><code>_score</code>字段没有经过计算，因为它没有用作排序(想强制计算其相关性，可以设置<code>track_scores</code>为<code>true</code>)</li><li>增加了一个<code>sort</code>字段，其中<code>date</code>字段被转为毫秒当作排序依据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 1 &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>排序结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hits&quot; : &#123;</span><br><span class="line">  &quot;total&quot; : 6,</span><br><span class="line">  &quot;max_score&quot; : null, &lt;1&gt;</span><br><span class="line">  &quot;hits&quot; : [ &#123;</span><br><span class="line">    &quot;_index&quot; : &quot;us&quot;,</span><br><span class="line">    &quot;_type&quot; : &quot;tweet&quot;,</span><br><span class="line">    &quot;_id&quot; : &quot;14&quot;,</span><br><span class="line">    &quot;_score&quot; : null, &lt;1&gt;</span><br><span class="line">    &quot;_source&quot; : &#123;</span><br><span class="line">      &quot;date&quot;: &quot;2014-09-24&quot;,</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;sort&quot; : [ 1411516800000 ] &lt;2&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为缩写，你可以只指定要排序的字段名称<code>&quot;sort&quot;: &quot;number_of_children&quot;</code>，字段值默认以顺序排列，而<code>_score</code>默认以倒序排列</p></li><li><p>多级排序(结果集会先用第一排序字段来排序，当用用作第一字段排序的值相同的时候，然后再用第二字段对第一排序值相同的文档进行排序，以此类推)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;tweet&quot;: &quot;manage text search&quot; &#125;&#125;,</span><br><span class="line">      &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 2 &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123; &quot;date&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;,</span><br><span class="line">    &#123; &quot;_score&quot;: &#123; &quot;order&quot;: &quot;desc&quot; &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>字符查询也支持相关性排序，在查询字符串使用<code>sort</code>参数就可以<code>GET /_search?sort=date:desc&amp;sort=_score&amp;q=text</code></p></li><li><p>对于数字和日期数组，可以从多个值中取出一个来进行排序，你可以使用<code>min</code>,<code>max</code>,<code>avg</code>或<code>sum</code>这些模式。比说你可以在<code>dates</code>字段中用最早的日期来进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;sort&quot;: &#123;</span><br><span class="line">  &quot;dates&quot;: &#123;</span><br><span class="line">    &quot;order&quot;: &quot;asc&quot;,</span><br><span class="line">    &quot;mode&quot;: &quot;min&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>analyzed</code>字符串字段同时也是多值字段，在这些字段上排序往往得不到你想要的值，为了使一个string字段可以进行排序，它必须是完整的<code>not_analyzed</code>字符串(对<code>analyzed</code>字段进行强制排序会消耗大量内存)</p><ol><li><code>tweet</code>字段用于全文本的<code>analyzed</code>索引方式不变</li><li>新增的<code>tweet.raw</code>子字段索引方式是<code>not_analyzed</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;tweet&quot;: &#123; &lt;1&gt;</span><br><span class="line">  &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;english&quot;,</span><br><span class="line">  &quot;fields&quot;: &#123;</span><br><span class="line">    &quot;raw&quot;: &#123; &lt;2&gt;</span><br><span class="line">      &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">      &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>给数据重建索引后，我们既可以使用<code>tweet</code>字段进行全文本搜索，也可以用<code>tweet.raw</code>字段进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;tweet&quot;: &quot;elasticsearch&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: &quot;tweet.raw&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-相关性简介"><a href="#2-相关性简介" class="headerlink" title="2. 相关性简介"></a>2. 相关性简介</h4><ul><li>每个文档都有相关性评分，用一个相对的浮点数字段<code>_score</code>来表示(<code>_score</code>的评分越高，相关性越高)</li><li>查询语句会为每个文档添加一个<code>_score</code>字段，评分的计算方式取决于不同的查询类型，不同的查询语句用于不同的目的</li><li><code>fuzzy</code>查询会计算与关键词的拼写相似程度，<code>terms</code>查询会计算找到的内容与关键词组成部分匹配的百分比，但是一般意义上我们说的全文本搜索是指计算内容与关键词的类似程度</li><li>ElasticSearch的相似度算法被定义为TF/IDF，即检索词频率/反向文档频率<ol><li>检索词频率：出现频率越高，相关性也越高。字段中出现过5次要比只出现过1次的相关性高</li><li>反向文档频率：检索词出现在多数文档中会比出现在少数文档中的权重更低，即检验一个检索词在文档中的普遍重要性</li><li>字段长度准则：检索词出现在一个短的title要比同样的词出现在一个长的content字段权重更高</li></ol></li><li>单个查询可以使用TF/IDF评分标准或其他方式，比如短语查询中检索词的距离或模糊查询里的检索词相似度</li><li>相关性并不只是全文本检索的专利。也适用于<code>yes|no</code>的子句，匹配的子句越多，相关性评分越高</li><li>如果多条查询子句被合并为一条复合查询语句，比如<code>bool</code>查询，则每个查询子句计算得出的评分会被合并到总的相关性评分中</li></ul><h4 id="3-理解评分标准"><a href="#3-理解评分标准" class="headerlink" title="3. 理解评分标准"></a>3. 理解评分标准</h4><ul><li><p>当调试一条复杂的查询语句时，想要理解相关性评分<code>_score</code>是比较困难的。ElasticSearch在每个查询语句中都有一个<code>explain</code>参数，将<code>explain</code>设为<code>true</code>就可以得到更详细的信息</p><ol><li><code>explain</code>参数可以让返回结果添加一个<code>_score</code>评分的得来依据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /_search?explain &lt;1&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;tweet&quot; : &quot;honeymoon&quot; &#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>增加一个<code>explain</code>参数会为每个匹配到的文档产生一大堆额外内容，但是花时间去理解它是很有意义的</p><ol><li>普通查询返回的元数据</li><li>加入了该文档来自于哪个节点哪个分片上的信息(因为词频率和文档频率是在每个分片中计算出来的)</li><li><code>honeymoon</code>相关性评分计算的总结。告诉了我们<code>honeymoon</code>在<code>tweet</code>字段中的检索词频率/反向文档频率或TF/IDF</li><li>检索词频率。检索词<code>honeymoon</code>在<code>tweet</code>字段中的出现次数</li><li>反向文档频率。检索词<code>honeymoon</code>在<code>tweet</code>字段在当前文档出现次数与索引中其他文档的出现总数的比率</li><li>字段长度准则。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;us&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;tweet&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;12&quot;,</span><br><span class="line">  &quot;_score&quot; : 0.076713204,</span><br><span class="line">  &quot;_source&quot; : &#123; ... trimmed ... &#125;, &lt;1&gt;</span><br><span class="line">  &quot;_shard&quot; : 1,</span><br><span class="line">  &quot;_node&quot; : &quot;mzIVYCsqSWCG_M_ZffSs9Q&quot;, &lt;2&gt;</span><br><span class="line">  &quot;_explanation&quot;: &#123; &lt;3&gt;</span><br><span class="line">    &quot;description&quot;: &quot;weight(tweet:honeymoon in 0)[PerFieldSimilarity], result of:&quot;,</span><br><span class="line">    &quot;value&quot;: 0.076713204,</span><br><span class="line">    &quot;details&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;description&quot;: &quot;fieldWeight in 0, product of:&quot;,</span><br><span class="line">        &quot;value&quot;: 0.076713204,</span><br><span class="line">        &quot;details&quot;: [</span><br><span class="line">          &#123; &lt;4&gt;</span><br><span class="line">            &quot;description&quot;: &quot;tf(freq=1.0), with freq of:&quot;,</span><br><span class="line">            &quot;value&quot;: 1,</span><br><span class="line">            &quot;details&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;description&quot;: &quot;termFreq=1.0&quot;,</span><br><span class="line">                &quot;value&quot;: 1</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; &lt;5&gt;</span><br><span class="line">            &quot;description&quot;: &quot;idf(docFreq=1, maxDocs=1)&quot;,</span><br><span class="line">            &quot;value&quot;: 0.30685282</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; &lt;6&gt;</span><br><span class="line">            &quot;description&quot;: &quot;fieldNorm(doc=0)&quot;,</span><br><span class="line">            &quot;value&quot;: 0.25,</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>JSON形式的<code>explain</code>描述是难以阅读的但是转成YAML会好很多，只需要在参数中加上<code>format=yaml</code></p></li><li><p>当<code>explain</code>选项加到某一文档上时，它会告诉你为何这个文档会被匹配，以及一个文档为何没有被匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET /us/tweet/12/_explain</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123; &quot;term&quot; : &#123; &quot;user_id&quot; : 2 &#125;&#125;,</span><br><span class="line">      &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;tweet&quot; : &quot;honeymoon&quot; &#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了上面我们看到的完整描述外，我们还可以看到这样的描述：<code>failure to match filter: cache(user_id:[2 TO 2])</code>(也就是说我们的<code>user_id</code>过滤子句使该文档不能匹配到)</p></li></ul><h4 id="4-数据字段"><a href="#4-数据字段" class="headerlink" title="4. 数据字段"></a>4. 数据字段</h4><ul><li>当对一个字段进行排序时，ElasticSearch需要进入每个匹配到的文档得到相关的值。倒排索引在用于搜索时是非常卓越的，但却不是理想的排序结构<ul><li>当搜索的时候，我们需要用检索词去遍历所有的文档</li><li>当排序的时候，我们需要遍历文档中所有的值，我们需要做反倒序排列操作</li></ul></li><li>为了提高排序效率，ElasticSearch会将所有字段的值加载到内存中，这就叫做数据字段(ElasticSearch将所有字段数据加载到内存中并不是匹配到的那部分数据。而是索引下所有文档中的值，包括所有类型)</li><li>将所有字段数据加载到内存中是因为从硬盘反向倒排索引是非常缓慢的。尽管你这次请求需要的是某些文档中的部分数据，但你下个请求却需要另外的数据，所以将所有字段数据一次性加载到内存中是十分必要的。</li><li>ElasticSearch中的字段数据常被应用到以下场景：<ol><li>对一个字段进行排序</li><li>对一个字段进行聚合</li><li>某些过滤，比如地理位置过滤</li><li>某些与字段相关的脚本计算</li></ol></li><li>毫无疑问，这会消耗掉很多内存，尤其是大量的字符串数据(string字段可能包含很多不同的值，比如邮件内容)</li><li>值得庆幸的是，内存不足是可以通过横向扩展解决的，我们可以增加更多的节点到集群</li></ul><h3 id="八、执行分布式检索"><a href="#八、执行分布式检索" class="headerlink" title="八、执行分布式检索"></a>八、执行分布式检索</h3><h4 id="1-查询和取回阶段"><a href="#1-查询和取回阶段" class="headerlink" title="1. 查询和取回阶段"></a>1. 查询和取回阶段</h4><ul><li>一个CRUD操作(create read update delete)只处理一个单独的文档。文档的唯一性由<code>_index</code>,<code>_type</code>和<code>routing-value</code>(通常默认是该文档的<code>_id</code>)的组合来确定。这意味着我们可以准确知道集群中的哪个分片持有这个文档</li><li>由于不知道哪个文档会匹配查询(文档可能存放在集群中的任意分片上)，所以搜索需要一个更复杂的模型。一个搜索不得不通过查询每一个我们感兴趣的索引的分片副本，来看是否含有任何匹配的文档</li><li>但是，找到所有匹配的文档只完成了这件事的一半。在搜索(search)API返回一页结果前，来自多个分片的结果必须被组合放到一个有序列表中。因此，搜索的执行过程分两个阶段，称为查询然后取回(query then fetch)</li></ul><h4 id="2-搜索选项"><a href="#2-搜索选项" class="headerlink" title="2. 搜索选项"></a>2. 搜索选项</h4><ol><li><code>preference</code>(偏爱)<br><code>preference</code>参数允许你控制使用哪个分片或节点来处理搜索请求(接受如下一些参数<code>_primary</code> <code>_primary_first</code> <code>_local</code> <code>_only_node:xyz</code> <code>_prefer_node:xyz</code> <code>_shards:2,3</code>)。然而通常最有用的值是一些随机字符串，它们可以避免结果震荡问题(the bouncing results problem)</li><li><code>timeout</code>(超时)<br>通常，协调节点会等待接收所有分片的回答。如果有一个节点遇到问题，它会拖慢整个搜索请求。<code>timeout</code>参数告诉协调节点最多等待多久，就可以放弃等待而将已有结果返回 </li><li><code>routing</code>(路由选择)<br>在路由值那节里，我们解释了如何在建立索引时提供一个自定义的<code>routing</code>参数来保证所有相关的document(如属于单个用户的document)被存放在一个单独的分片中。在搜索时，你可以指定一个或多个<code>routing</code>值来限制只搜索那些分片而不是搜索<code>index</code>里的全部分片。<code>GET /_search?routing=user_1,user2</code></li><li>search_type(搜索类型)<br>虽然<code>query_then_fetch</code>是默认的搜索类型，但也可以根据特定目的指定其它的搜索类型，例如：<code>GET /_search?search_type=count</code><ul><li><code>count</code><br><code>count</code>(计数)搜索类型只有一个query(查询)的阶段。当不需要搜索结果只需要知道满足查询的document的数量时，可以使用这个查询类型</li><li><code>query_and_fetch</code><br><code>query_and_fetch</code>(查询并且取回)搜索类型将查询和取回阶段合并成一个步骤。这是一个内部优化选项，当搜索请求的目标只是一个分片时可以使用，例如指定了<code>routing</code>(路由选择)值时。虽然你可以手动选择使用这个搜索类型，但是这么做基本上不会有什么效果</li><li><code>dfs_query_then_fetch</code>和<code>dfs_query_and_fetch</code><br>dfs搜索类型有一个预查询的阶段，它会从全部相关的分片里取回项目频数来计算全局的项目频数。我们将在relevance-isbroken(相关性被破坏)里进一步讨论这个</li><li><code>scan</code><br>scan(扫描)搜索类型是和scroll(滚屏)API连在一起使用的，可以高效地取回巨大数量的结果。它是通过禁用排序来实现的</li></ul></li></ol><h4 id="3-扫描和滚屏-scan-and-scroll"><a href="#3-扫描和滚屏-scan-and-scroll" class="headerlink" title="3. 扫描和滚屏(scan-and-scroll)"></a>3. 扫描和滚屏(scan-and-scroll)</h4><ul><li><code>scan</code>(扫描)搜索类型是和<code>scroll</code>(滚屏)API一起使用来从Elasticsearch里高效地取回巨大数量的结果而不需要付出深分页的代价</li></ul><ol><li><p>为了使用scan-and-scroll(扫描和滚屏)，需要执行一个搜索请求，将<code>search_type</code>设置成<code>scan</code>，并且传递一个<code>scroll</code>参数来告诉Elasticsearch滚屏应该持续多长时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /old_index/_search?search_type=scan&amp;scroll=1m &lt;1&gt;保持滚屏开启1分钟</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;size&quot;: 1000</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个请求的应答没有包含任何命中的结果，但是包含了一个Base-64编码的<code>_scroll_id</code>(滚屏id)字符串。现在我们可以将<code>_scroll_id</code>传递给<code>_search/scroll</code>末端来获取第一批结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /_search/scroll?scroll=1m &lt;1&gt;保持滚屏开启另一分钟</span><br><span class="line">&lt;2&gt;_scroll_id 可以在body或者URL里传递，也可以被当做查询参数传递</span><br><span class="line">&#123;</span><br><span class="line">  &quot;scroll_id&quot;: &quot;c2NhbjszOzIzOlp6OUZtMTZSU0J1ZDJmSnVxcmk1b0E7MjE6aFI5V0hUV0tSQUs0WVo3UjdHWUxJdzsyNjp1VHpJaFk5UlN6T1dNenpVWGN2RmFROzE7dG90YWxfaGl0czoxNTs=&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>滚屏请求也会返回一个新的<code>_scroll_id</code>。每次做下一个滚屏请求时，必须传递前一次请求返回的<code>_scroll_id</code></p></li></ol><ul><li>注意，要再次指定<code>?scroll=1m</code>。滚屏的终止时间会在我们每次执行滚屏请求时刷新，所以他只需要给我们足够的时间来处理当前批次的结果而不是所有的匹配查询的document。这个滚屏请求的应答包含了第一批次的结果</li><li>虽然指定了一个1000的<code>size</code>，但是获得了更多的document。当扫描时，size被应用到每一个分片上，所以我们在每个批次里最多或获得<code>size * number_of_primary_shards</code>(<code>size*主分片数</code>)个document</li><li>如果没有更多的命中结果返回，就处理完了所有的命中匹配的document</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch笔记（二）&quot;&gt;&lt;a href=&quot;#Elasticsearch笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch笔记（二）&quot;&gt;&lt;/a&gt;Elasticsearch笔记（二）&lt;/h2&gt;&lt;h3 id=&quot;六
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="database" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/"/>
    
      <category term="elasticsearch" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://huangdu.work/tags/elasticsearch/"/>
    
      <category term="非关系型数据库" scheme="https://huangdu.work/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch笔记（一）</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/database/elasticsearch/elasticsearch%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://huangdu.work/笔记/database/elasticsearch/elasticsearch笔记（一）/</id>
    <published>2019-12-21T16:00:00.000Z</published>
    <updated>2020-02-03T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Elasticsearch笔记（一）"><a href="#Elasticsearch笔记（一）" class="headerlink" title="Elasticsearch笔记（一）"></a>Elasticsearch笔记（一）</h2><h3 id="一、Elasticsearch概述"><a href="#一、Elasticsearch概述" class="headerlink" title="一、Elasticsearch概述"></a>一、Elasticsearch概述</h3><h4 id="1-Elasticsearch介绍"><a href="#1-Elasticsearch介绍" class="headerlink" title="1. Elasticsearch介绍"></a>1. Elasticsearch介绍</h4><ul><li>Elasticsearch是一个实时分布式搜索和分析引擎，它让你以前所未有的速度处理大数据成为可能</li><li>Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎</li><li>无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库</li></ul><h4 id="2-安装并运行Elasticsearch"><a href="#2-安装并运行Elasticsearch" class="headerlink" title="2. 安装并运行Elasticsearch"></a>2. 安装并运行Elasticsearch</h4><ul><li>安装Elasticsearch唯一的要求是安装<a href="www.java.com">java</a></li><li>你可以下载最新版本的<a href="elasticsearch.org/download">elasticsearch</a></li><li>后台运行 <code>./bin/elasticsearch -d</code></li><li>查看es是否正常运行 <code>curl &#39;http://localhost:9200/?pretty&#39;</code></li><li>关闭es <code>curl -XPOST &#39;http://localhost:9200/_shutdown&#39;</code></li></ul><h4 id="3-和Elasticsearch交互"><a href="#3-和Elasticsearch交互" class="headerlink" title="3. 和Elasticsearch交互"></a>3. 和Elasticsearch交互</h4><ul><li>基于HTTP协议，以JSON为数据交互格式的RESTful API</li><li><code>curl -X&lt;VERB&gt; &lt;PROTOCOL&gt;://&lt;HOST&gt;/&lt;PORT&gt;?&lt;QUERY_STRING&gt; -d &lt;BODY&gt;</code><ul><li><code>VERB</code> http方法:<code>GET</code>,<code>POST</code>,<code>PUT</code>,<code>HEAD</code>,<code>DELETE</code></li><li><code>PROTOCOL</code> <code>http</code>或<code>https</code>协议(只有在Elasticsearch前面有https代理的时候可用)</li><li><code>HOST</code> Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫<code>localhost</code></li><li><code>PORT</code> Elasticsearch HTTP服务所在的端口，默认为<code>9200</code></li><li><code>QUERY_STRING</code> 一些可选的查询请求参数，例如<code>?pretty</code>参数将使请求返回更加美观易读的JSON数据</li><li><code>BODY</code> 一个JSON格式的请求主体(如果请求需要的话)</li></ul></li><li>linux利用<code>curl</code>命令注意<code>-d</code>后面的参数部分有些特殊字符需要转义(例<code>,</code>)</li><li>linux利用<code>curl</code>命令，请求体可放在文件中 <code>curl -XPOST http://localhost:9200/_bulk --data-binary @requests</code>(bulk API需要，其中<code>requests</code>为请求体文件)</li><li>简写表示形式，省略<code>PROTOCOL</code>,<code>HOST</code>,<code>PORT</code>(计算集群中的文档数量) <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="4-面向文档"><a href="#4-面向文档" class="headerlink" title="4. 面向文档"></a>4. 面向文档</h4><ul><li>Elastic本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个Elastic实例</li><li>单个Elastic实例称为一个节点(node)，一组节点构成一个集群(cluster)</li><li>Elastic数据管理的顶层单位就叫做Index(索引)，相当于单个数据库，每个Index(即数据库)的名字必须是小写(Elastic会索引所有字段，经过处理后写入一个反向索引(Inverted Index)，查找数据的时候，直接查找该索引)</li><li>Index里面单条的记录称为Document(文档)，许多条Document构成了一个Index，Document使用JSON格式表示</li><li>Document可以分组，这种分组就叫做Type，它是虚拟的逻辑分组，用来过滤Document，不同的Type应该有相似的结构(schema)</li><li>id字段不能在这个组是字符串，在另一个组是数值，这是与关系型数据库的表的一个区别，性质完全不同的数据(比如products和logs)应该存成两个Index，而不是一个Index里面的两个Type(虽然可以做到)</li><li>Elastic与关系数据库的对比  <table><thead><tr><th align="center">关系数据库</th><th align="center">数据库</th><th align="center">表</th><th align="center">行</th><th align="center">列</th></tr></thead><tbody><tr><td align="center">Elasticsearch</td><td align="center">索引(Index)</td><td align="center">类型(Type)</td><td align="center">文档(Documents)</td><td align="center">字段(Fields)</td></tr></tbody></table></li></ul><h4 id="5-Elasticsearch简单教程"><a href="#5-Elasticsearch简单教程" class="headerlink" title="5. Elasticsearch简单教程"></a>5. Elasticsearch简单教程</h4><ol><li><p>索引员工文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PUT /iflytek/employee/1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;first_name&quot; : &quot;John&quot;,</span><br><span class="line">  &quot;last_name&quot; : &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot; : 25,</span><br><span class="line">  &quot;about&quot; : &quot;I love to go rock climbing&quot;,</span><br><span class="line">  &quot;interests&quot;: [ &quot;sports&quot;, &quot;music&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">PUT /iflytek/employee/2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;first_name&quot; : &quot;Jane&quot;,</span><br><span class="line">  &quot;last_name&quot; : &quot;Smith&quot;,</span><br><span class="line">  &quot;age&quot; : 32,</span><br><span class="line">  &quot;about&quot; : &quot;I like to collect rock albums&quot;,</span><br><span class="line">  &quot;interests&quot;: [ &quot;music&quot; ]</span><br><span class="line">&#125;</span><br><span class="line">PUT /iflytek/employee/3</span><br><span class="line">&#123;</span><br><span class="line">  &quot;first_name&quot; : &quot;Douglas&quot;,</span><br><span class="line">  &quot;last_name&quot; : &quot;Fir&quot;,</span><br><span class="line">  &quot;age&quot; : 35,</span><br><span class="line">  &quot;about&quot;: &quot;I like to build cabinets&quot;,</span><br><span class="line">  &quot;interests&quot;: [ &quot;forestry&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据id操作员工文档</p><ul><li><code>GET /iflytek/employee/1</code> 查</li><li><code>DELETE /iflytek/employee/1</code> 删</li><li><code>PUT /iflytek/employee/1</code> 改</li><li><code>HEAD /iflytek/employee/1</code> 检查某文档是否存在(<code>curl</code>使用时加<code>-i</code>参数，信息在响应头中)</li></ul></li><li><p>轻量搜索</p><ul><li><code>GET /iflytek/employee/_search</code> 默认情况下搜索会返回前10个结果</li><li><code>GET /iflytek/employee/_search?q=last_name:Smith</code> 查询字符串(query string)搜索，轻量级搜索</li><li><code>GET /iflytek/employee/_search?q=age[30 TO 60]&amp;sort=age:desc&amp;from=0&amp;size=2</code> 查询年龄为30-60之间，降序排序，分页查询</li></ul></li><li><p>使用查询表达式搜索(DSL,Domain Specific Language,特定领域语言)</p><ul><li><p>搜索指定字段值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;match&quot; : &#123;</span><br><span class="line">      &quot;last_name&quot; : &quot;Smith&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>搜索指定字段值(加过滤器)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;filtered&quot; : &#123;</span><br><span class="line">      &quot;filter&quot; : &#123;</span><br><span class="line">        &quot;range&quot; : &#123;</span><br><span class="line">          &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;query&quot; : &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">          &quot;last_name&quot; : &quot;smith&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全文搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;match&quot; : &#123;</span><br><span class="line">      &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>短语搜索(比全文搜索更具有针对性)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;match_phrase&quot; : &#123;</span><br><span class="line">      &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>高亮搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : &#123;</span><br><span class="line">    &quot;match_phrase&quot; : &#123;</span><br><span class="line">      &quot;about&quot; : &quot;rock climbing&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;highlight&quot;: &#123;</span><br><span class="line">    &quot;fields&quot; : &#123;</span><br><span class="line">      &quot;about&quot; : &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分析(聚合查询)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;all_interests&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123; &quot;field&quot;: &quot;interests&quot; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>聚合和精确查询组合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;last_name&quot;: &quot;smith&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;all_interests&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;interests&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>分级汇总(统计每种兴趣下职员的平均年龄)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET /iflytek/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot; : &#123;</span><br><span class="line">    &quot;all_interests&quot; : &#123;</span><br><span class="line">      &quot;terms&quot; : &#123; </span><br><span class="line">        &quot;field&quot; : &quot;interests&quot; </span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;avg_age&quot; : &#123;</span><br><span class="line">          &quot;avg&quot; : &#123; </span><br><span class="line">            &quot;field&quot; : &quot;age&quot; </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="6-分布式特性"><a href="#6-分布式特性" class="headerlink" title="6. 分布式特性"></a>6. 分布式特性</h4><ul><li>Elasticsearch可以横向扩展至数百(甚至数千)的服务器节点，同时可以处理PB级数据。Elasticsearch天生就是分布式的，并且在设计时屏蔽了分布式的复杂性</li><li>Elasticsearch在分布式方面几乎是透明的</li></ul><h3 id="二、Elasticsearch分布式"><a href="#二、Elasticsearch分布式" class="headerlink" title="二、Elasticsearch分布式"></a>二、Elasticsearch分布式</h3><h4 id="1-集群内的原理"><a href="#1-集群内的原理" class="headerlink" title="1. 集群内的原理"></a>1. 集群内的原理</h4><ul><li><p>集群健康 <code>GET /_cluster/health</code></p></li><li><p>创建索引(设置主分片数<code>number_of_shards</code>和复制分片数<code>number_of_replicas</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /website</span><br><span class="line">&#123;</span><br><span class="line">  &quot;settings&quot; : &#123;</span><br><span class="line">    &quot;number_of_shards&quot; : 3,</span><br><span class="line">    &quot;number_of_replicas&quot; : 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>手动分配分片所在节点的方式</p><ol><li><p>关闭分片自动分配所在节点(改为<code>all</code>开启)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT 10.3.172.112:9200/_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  &quot;transient&quot;:&#123;</span><br><span class="line">    &quot;cluster.routing.allocation.enable&quot;:&quot;none&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移动指定分片到指定节点  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST /_cluster/reroute</span><br><span class="line">&#123;</span><br><span class="line">  &quot;commands&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;move&quot;: &#123;</span><br><span class="line">        &quot;index&quot;: &quot;website&quot;,</span><br><span class="line">        &quot;shard&quot;: 1,</span><br><span class="line">        &quot;from_node&quot;: &quot;10.3.172.112&quot;,</span><br><span class="line">        &quot;to_node&quot;: &quot;10.3.172.111&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h4 id="2-分布式文档存储"><a href="#2-分布式文档存储" class="headerlink" title="2. 分布式文档存储"></a>2. 分布式文档存储</h4><ol><li><code>routing</code>参数<ul><li><code>shard = hash(routing) % number_of_primary_shards</code> 计算文档属于哪个分片</li><li><code>get</code>,<code>index</code>,<code>delete</code>,<code>bulk</code>,<code>update</code>,<code>mget</code>都可接收一个<code>routing</code>参数，它用来自定义文档到分片的映射</li></ul></li><li><code>replication</code>参数<ul><li><code>replication</code>复制默认的值是<code>sync</code>这将导致主分片得到复制分片的成功响应后才返回</li><li>如果你设置<code>replication</code>为<code>async</code>，请求在主分片上被执行后就会返回给客户端，它依旧会转发请求给复制节点，但你将不知道复制节点成功与否</li><li>上面的这个选项不建议使用，默认的<code>sync</code>复制允许Elasticsearch强制反馈传输，<code>async</code>复制可能会因为在不等待其它分片就绪的情况下发送过多的请求而使Elasticsearch过载</li></ul></li><li><code>consistency</code>参数<ul><li>默认主分片在尝试写入时需要规定数量(quorum)或过半的分片(可以是主节点或复制节点)可用，这是防止数据被写入到错的网络分区</li><li>规定的数量计算公式<code>int( (primary + number_of_replicas) / 2 ) + 1</code></li></ul></li><li><code>timeout</code>参数<ul><li>当分片副本不足时Elasticsearch会等待更多的分片出现，默认等待一分钟</li><li>可以设置<code>timeout</code>参数让它终止的更早，<code>100</code>表示100毫秒，<code>30s</code>表示30秒</li></ul></li></ol><ul><li><code>update</code>API接受<code>routing</code>,<code>replication</code>,<code>consistency</code>和<code>timout</code>参数</li><li><code>mget</code>API的<code>routing</code>参数可以被docs中的每个文档设置</li><li><code>bulk</code>API还可以在最上层使用<code>replication</code>和<code>consistency</code>参数，<code>routing</code>参数则在每个请求的元数据中使用</li></ul><h3 id="三、数据输入和输出"><a href="#三、数据输入和输出" class="headerlink" title="三、数据输入和输出"></a>三、数据输入和输出</h3><h4 id="1-文档元数据"><a href="#1-文档元数据" class="headerlink" title="1. 文档元数据"></a>1. 文档元数据</h4><ul><li>一个文档不只有数据，它还包含了元数据(metadata):</li><li><code>_index</code> 文档存储的地方</li><li><code>_type</code> 文档代表的对象的类(每个类型type都有自己的映射mapping或者结构定义， 就像传统数据库表中的列一样)</li><li><code>_id</code> 文档的唯一标识</li><li>其它元数据(例版本号<code>_version</code>)</li></ul><h4 id="2-索引文档"><a href="#2-索引文档" class="headerlink" title="2. 索引文档"></a>2. 索引文档</h4><ul><li><p>指定id新增  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Still trying this out...&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2014/01/01&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自增id新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My second blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Still trying this out...&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2014/01/02&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-检索文档"><a href="#3-检索文档" class="headerlink" title="3. 检索文档"></a>3. 检索文档</h4><ul><li><code>GET /website/blog/123?pretty</code> 美化输出</li><li><code>GET /website/blog/123?_source=title,text</code> 检索文档的指定字段</li><li><code>GET /website/blog/123/_source</code> 不要元数据</li><li><code>curl -XHEAD -i http://localhost:9200/website/blog/123</code> (检查文档是否存在)</li></ul><h4 id="4-更新整个文档"><a href="#4-更新整个文档" class="headerlink" title="4. 更新整个文档"></a>4. 更新整个文档</h4><ul><li>文档在Elasticsearch中是不可变的，我们不能修改他们。如果需要更新已存在的文档，可以使用索引文档章节提到的index API重建索引(reindex)</li><li>update API似乎允许你修改文档的局部，但事实上Elasticsearch遵循与之前所说完全相同的过程  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;I am starting to get the hang of this...&quot;,</span><br><span class="line">  &quot;date&quot;: &quot;2014/01/01&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="5-创建一个新文档"><a href="#5-创建一个新文档" class="headerlink" title="5. 创建一个新文档"></a>5. 创建一个新文档</h4><ul><li><p>使用自增id保证文档新增而不是覆盖原来的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用指定id，在id已被使用的时候创建失败，方法一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123?op_type=create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用指定id，在id已被使用的时候创建失败，方法二</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/123/_create</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="6-删除文档"><a href="#6-删除文档" class="headerlink" title="6. 删除文档"></a>6. 删除文档</h4><ul><li>删除一个文档也不会立即从磁盘上移除，它只是被标记成已删除。Elasticsearch将会在你之后添加更多索引的时候才会在后台进行删除内容的清理</li><li><code>DELETE /website/blog/123</code></li></ul><h4 id="7-Elasticsearch版本控制"><a href="#7-Elasticsearch版本控制" class="headerlink" title="7. Elasticsearch版本控制"></a>7. Elasticsearch版本控制</h4><ul><li>为了保证数据在多线程操作下的准确性ES要进行版本控制(CAS无锁)</li><li>悲观锁和乐观锁<ul><li>悲观锁：假设会发生并发冲突，屏蔽一切可能违反数据准确性的操作</li><li>乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性</li></ul></li><li>内部版本控制和外部版本控制<ul><li>内部版本控制：<code>_version</code>自增长，修改数据后，<code>_version</code>会自动的加1</li><li>外部版本控制：为了保持<code>_version</code>与外部版本控制的数值一致</li><li>使用<code>version_type=external</code>检查数据当前的version值是否小于请求中的version值</li></ul></li></ul><h4 id="8-带版本控制的操作"><a href="#8-带版本控制的操作" class="headerlink" title="8. 带版本控制的操作"></a>8. 带版本控制的操作</h4><ul><li><p>我们只希望文档的<code>_version</code>是1时更新才生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/1?version=1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用外部版本号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT /website/blog/2?version=5&amp;version_type=external</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;: &quot;My first external blog entry&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;Starting to get the hang of this...&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="9-文档局部更新-本质上同更新整个文档"><a href="#9-文档局部更新-本质上同更新整个文档" class="headerlink" title="9. 文档局部更新(本质上同更新整个文档)"></a>9. 文档局部更新(本质上同更新整个文档)</h4><ul><li><p>update API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot; : &#123;</span><br><span class="line">    &quot;tags&quot; : [ &quot;testing&quot; ],</span><br><span class="line">    &quot;views&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用脚本局部更新(需要在elasticsearch.yml文件中配置<code>script.inline</code>和<code>script.indexed</code>为<code>true</code>)</p></li><li><p>使用脚本指定字段增加一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx._source.views+=1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用脚本指定字段增加内容，内容从参数指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx._source.tags+=new_tag&quot;,</span><br><span class="line">  &quot;params&quot; : &#123;</span><br><span class="line">    &quot;new_tag&quot; : &quot;search&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当满足特定条件的时候，脚本执行特定操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx.op = ctx._source.views == count ? &apos;delete&apos; : &apos;none&apos;&quot;,</span><br><span class="line">  &quot;params&quot; : &#123;</span><br><span class="line">    &quot;count&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当脚本所指定字段不存在时，初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/pageviews/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx._source.views+=1&quot;,</span><br><span class="line">  &quot;upsert&quot;: &#123;</span><br><span class="line">    &quot;views&quot;: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当更新发生冲突时，重新执行(5次)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /website/pageviews/1/_update?retry_on_conflict=5</span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot; : &quot;ctx._source.views+=1&quot;,</span><br><span class="line">  &quot;upsert&quot;: &#123;</span><br><span class="line">    &quot;views&quot;: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="10-检索多个文档-mget-API"><a href="#10-检索多个文档-mget-API" class="headerlink" title="10. 检索多个文档(mget API)"></a>10. 检索多个文档(mget API)</h4><ul><li><p>mget API参数是一个docs数组，数组的每个节点定义一个文档的<code>_index</code>、<code>_type</code>、<code>_id</code>元数据，如果你只想检索一个或几个确定的字段，也可以定义一个<code>_source</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot;:[</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;blog&quot;,</span><br><span class="line">      &quot;_id&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;_index&quot; : &quot;website&quot;,</span><br><span class="line">      &quot;_type&quot; : &quot;pageviews&quot;,</span><br><span class="line">      &quot;_id&quot; : 1,</span><br><span class="line">      &quot;_source&quot;: &quot;views&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>公共的参数可以在请求地址中指定，但是请求体中依然可以覆盖请求地址中参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;docs&quot; : [</span><br><span class="line">    &#123; &quot;_id&quot; : 2 &#125;,</span><br><span class="line">    &#123; &quot;_type&quot; : &quot;pageviews&quot;, &quot;_id&quot; : 1 &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查询多个id的简写方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  &quot;ids&quot; : [ &quot;2&quot;, &quot;1&quot; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="11-更省时的批量操作"><a href="#11-更省时的批量操作" class="headerlink" title="11. 更省时的批量操作"></a>11. 更省时的批量操作</h4><ul><li><p>bulk API允许我们使用单一请求来实现多个文档的<code>create</code> <code>index</code> <code>update</code>或<code>delete</code>。这对索引类似于日志活动这样的数据流非常有用，它们可以以成百上千的数据为一个批次按序进行索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body &#125;\n</span><br><span class="line">&#123; action: &#123; metadata &#125;&#125;\n</span><br><span class="line">&#123; request body &#125;\n</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>每行必须以<code>\n</code>符号结尾，包括最后一行。这些都是作为每行有效的分离而做的标记</p></li><li><p>每一行的数据不能包含未被转义的换行符，它们会干扰分析——这意味着JSON不能被美化打印</p></li><li><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建，指定id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My first blog post&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p>创建，不指定id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My second blog post&quot; &#125;</span><br></pre></td></tr></table></figure></li><li><p>放在一起例子(记得最后一个换行符)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; &quot;delete&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;create&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My first blog post&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;My second blog post&quot; &#125;</span><br><span class="line">&#123; &quot;update&quot;: &#123; &quot;_index&quot;: &quot;website&quot;, &quot;_type&quot;: &quot;blog&quot;, &quot;_id&quot;: &quot;123&quot;, &quot;_retry_on_conflict&quot; : 3&#125; &#125;</span><br><span class="line">&#123; &quot;doc&quot; : &#123;&quot;title&quot; : &quot;My updated blog post&quot;&#125; &#125;</span><br></pre></td></tr></table></figure></li><li><p>重复的内容可以不写在请求体中(依然可以覆盖，同mget)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /website/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;log&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;event&quot;: &quot;User logged in&quot; &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /website/log/_bulk</span><br><span class="line">&#123; &quot;index&quot;: &#123;&#125;&#125;</span><br><span class="line">&#123; &quot;event&quot;: &quot;User logged in&quot; &#125;</span><br><span class="line">&#123; &quot;index&quot;: &#123; &quot;_type&quot;: &quot;blog&quot; &#125;&#125;</span><br><span class="line">&#123; &quot;title&quot;: &quot;Overriding the default type&quot; &#125;</span><br></pre></td></tr></table></figure><ul><li>最佳大小并不是一个固定的数字。它完全取决于你的硬件、你文档的大小和复杂度以及索引和搜索的负载</li><li>一个好的批次最好保持在5-15MB大小间</li></ul><h3 id="四、搜索-基本的工具"><a href="#四、搜索-基本的工具" class="headerlink" title="四、搜索(基本的工具)"></a>四、搜索(基本的工具)</h3><h4 id="1-空搜索"><a href="#1-空搜索" class="headerlink" title="1. 空搜索"></a>1. 空搜索</h4><ul><li><code>GET /_search</code></li><li><code>GET /_search?timeout=10ms</code></li><li>需要注意的是<code>timeout</code>不会停止执行查询，它仅仅告诉你目前顺利返回结果的节点然后关闭连接。在后台，其他分片可能依旧执行查询，尽管结果已经被发送</li></ul><h4 id="2-多索引和多类型"><a href="#2-多索引和多类型" class="headerlink" title="2. 多索引和多类型"></a>2. 多索引和多类型</h4><ul><li><code>/_search</code> 在所有索引的所有类型中搜索</li><li><code>/gb/_search</code> 在索引gb的所有类型中搜索</li><li><code>/gb,us/_search</code> 在索引gb和us的所有类型中搜索</li><li><code>/g*,u*/_search</code> 在以g或u开头的索引的所有类型中搜索</li><li><code>/gb/user/_search</code> 在索引gb的类型user中搜索</li><li><code>/gb,us/user,tweet/_search</code> 在索引gb和us的类型为user和tweet中搜索</li><li><code>/_all/user,tweet/_search</code> 在所有索引的user和tweet中搜索</li></ul><h4 id="3-分页搜索"><a href="#3-分页搜索" class="headerlink" title="3. 分页搜索"></a>3. 分页搜索</h4><ul><li><code>GET /_search?size=5</code>(<code>size</code>默认10)</li><li><code>GET /_search?size=5&amp;from=5</code>(<code>from</code>跳过开始的结果数，默认0)</li><li>注意深度分页影响性能</li></ul><h4 id="4-轻量搜索"><a href="#4-轻量搜索" class="headerlink" title="4. 轻量搜索"></a>4. 轻量搜索</h4><ul><li>search API有两种<ol><li>简易版的查询字符串(query string)将所有参数通过查询字符串定义</li><li>使用JSON完整的表示请求体(request body)，这种富搜索语言叫做结构化查询语句(DSL)</li></ol></li><li>查询字符串搜索对于在命令行下运行点对点(ad hoc)查询特别有用<ul><li><code>GET /_all/tweet/_search?q=tweet:elasticsearch</code></li></ul></li><li><code>+</code>前缀表示语句匹配条件必须被满足，<code>-</code>前缀表示条件必须不被满足，所有条件如果没有<code>+</code>或<code>-</code>表示条件是可选的<ul><li>条件 <code>+name:john +tweet:mary</code> url编码(percent encoding，百分比编码)</li><li><code>GET /_search?q=%2Bname%3Ajohn+%2Btweet%3Amary</code> </li></ul></li><li>返回包含”mary”字符的所有文档的简单搜索<ul><li><code>GET /_search?q=mary</code> </li></ul></li><li>更复杂的语句<ul><li>条件：1.<code>name</code>字段包含<code>mary</code>或<code>john</code> 2.<code>date</code>晚于<code>2014-09-10</code> 3.<code>_all</code>字段包含<code>aggregations</code>或<code>geo</code></li><li><code>+name:(mary john) +date:&gt;2014-09-10 +(aggregations geo)</code> </li><li><code>GET /_search?q=%2Bname%3A(mary+john)+%2Bdate%3A%3E2014-09-10+%2B(aggregations+geo)</code></li></ul></li></ul><h3 id="五、映射和分析"><a href="#五、映射和分析" class="headerlink" title="五、映射和分析"></a>五、映射和分析</h3><h4 id="1-确切值-Exact-values-和全文-Full-text"><a href="#1-确切值-Exact-values-和全文-Full-text" class="headerlink" title="1. 确切值(Exact values)和全文(Full text)"></a>1. 确切值(Exact values)和全文(Full text)</h4><ul><li>Elasticsearch中的数据可以概括的分为两类，精确值和全文</li><li>精确值如它们听起来那样精确。例如日期或者用户ID，但字符串也可以表示精确值，例如用户名或邮箱地址。对于精确值来讲，<code>Foo</code>和<code>foo</code>是不同的，<code>2014</code>和<code>2014-09-15</code>也是不同的</li><li>全文是指文本数据(通常以人类容易识别的语言书写)，例如一个推文的内容或一封邮件的内容</li><li>精确值很容易查询，结果是二进制的，要么匹配查询，要么不匹配。查询全文数据要微妙的多，我们问的不只是这个文档匹配查询吗，而是该文档匹配查询的程度有多大</li></ul><h4 id="2-倒排索引"><a href="#2-倒排索引" class="headerlink" title="2. 倒排索引"></a>2. 倒排索引</h4><ol><li>为了方便在全文文本字段中进行这些类型的查询，Elasticsearch首先对文本分析(analyzes)，然后使用结果建立一个倒排索引</li><li>Elasticsearch使用一种叫做倒排索引(inverted index)的结构来做快速的全文搜索。倒排索引由在文档中出现的唯一的单词列表，以及对于每个单词在文档中的位置组成</li><li>为了创建倒排索引，我们首先切分每个文档的指定字段为单独的单词(<code>terms</code> <code>tokens</code>)把所有的唯一词放入列表并排序</li><li>为了找到确实存在于索引中的词，索引文本和查询字符串都要标准化为相同的形式，这个表征化和标准化的过程叫做分词(analysis)</li></ol><h4 id="3-分析与分析器"><a href="#3-分析与分析器" class="headerlink" title="3. 分析与分析器"></a>3. 分析与分析器</h4><ul><li>一个分析器(analyzer)只是一个包装用于将三个功能放到一个包里<ol><li>字符串经过字符过滤器(character filter)，它们的工作是在表征化前处理字符串。字符过滤器能够去除HTML标记，或者转换 “&amp;” 为 “and” </li><li>分词器(tokenizer)将字符串表征化为独立的词(断词)。一个简单的分词器(tokenizer)可以根据空格或逗号将单词分开</li><li>每个词都通过所有表征过滤(token filters)，它可以修改词(例如将”Quick”转为小写)，去掉词(例如停用词像”a”、”and”、”the”等等)，或者增加词(例如同义词像”jump”和”leap”)</li></ol></li><li>Elasticsearch提供很多开箱即用的字符过滤器，分词器和表征过滤器。这些可以组合来创建自定义的分析器以应对不同的需求</li><li>Elasticsearch还附带了一些预装的分析器，可以直接使用它们(以下列出各分词器处理”Set the shape to semi-transparent by calling set_trans(5)”的结果)<ol><li>标准分析器(<code>standard</code>，Elasticsearch默认) (set, the, shape, to, semi, transparent, by, calling, set_trans, 5)</li><li>简单分析器(<code>simple</code>) (set, the, shape, to, semi, transparent, by, calling, set, trans)</li><li>空格分析器(<code>whitespace</code>) (Set, the, shape, to, semi-transparent, by, calling, set_trans(5))</li><li>语言分析器(<code>english</code>) (set, shape, semi, transpar, call, set_tran, 5)</li></ol></li><li>测试分析器<ul><li>查看指定文档指定字段分词情况<br><code>GET /iflytek/employee/1/_termvectors?fields=about</code></li><li>指定分词器分词<br><code>POST /_analyze?analyzer=standard {&quot;text&quot;: &quot;text content&quot;}</code></li><li>使用指定字段分词器分词<br><code>POST /iflytek/_analyze?field=about {&quot;text&quot;: &quot;text content&quot;}</code></li></ul></li><li>指定分析器 当Elasticsearch在你的文档中探测到一个新的字符串字段，它将自动设置它为全文string字段并用standard分析器分析(可以通过映射<code>mapping</code>设置)</li></ul><h4 id="4-映射"><a href="#4-映射" class="headerlink" title="4. 映射"></a>4. 映射</h4><ol><li><p>Elasticsearch为对字段类型进行猜测，动态生成了字段和类型的映射关系。默认字段<code>_all</code>是<code>string</code>类型</p></li><li><p>核心简单字段类型</p><table><thead><tr><th align="center">类型</th><th align="center">表示的数据类型</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">string</td></tr><tr><td align="center">Whole number</td><td align="center">byte,short,integer,long</td></tr><tr><td align="center">Floating point</td><td align="center">float,double</td></tr><tr><td align="center">Boolean</td><td align="center">boolean</td></tr><tr><td align="center">Date</td><td align="center">date</td></tr></tbody></table></li><li><p>当你索引一个包含新字段的文档，一个之前没有的字段，Elasticsearch将使用动态映射猜测字段类型，这类型来自于JSON的基本数据类型，使用以下规则</p><table><thead><tr><th align="center">JSON type</th><th align="center">Field type</th></tr></thead><tbody><tr><td align="center">Boolean: true or false</td><td align="center">boolean</td></tr><tr><td align="center">Whole number: 123</td><td align="center">long</td></tr><tr><td align="center">Floating point: 123.45</td><td align="center">double</td></tr><tr><td align="center">String, valid date: “2014-09-15”</td><td align="center">date</td></tr><tr><td align="center">String: “foo bar”</td><td align="center">string</td></tr></tbody></table></li><li><p>查看映射</p><ul><li><code>GET /gb/_mapping/tweet</code></li><li><code>GET /gb/_mapping</code></li></ul></li><li><p>自定义字段映射</p><ul><li><p>其它类型(<code>index</code>可设置<code>not_analyzed</code> <code>no</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;number_of_clicks&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;integer&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>string</code>类型(<code>index</code>参数控制字符串以何种方式被索引，可设置<code>analyzed</code> <code>not_analyzed</code> <code>no</code>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tag&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;not_analyzed&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定分词器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tweet&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;string&quot;,</span><br><span class="line">    &quot;analyzer&quot;: &quot;english&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>更新映射</p><ul><li>可以向已有映射中增加字段，但不能修改它。如果一个字段在映射中已经存在，这可能意味着那个字段的数据已经被索引。如果改变了字段映射，那已经被索引的数据将错误并且不能被正确的搜索到</li><li>可以更新一个映射来增加一个新字段，但是不能把已有字段的类型那个从analyzed改到not_analyzed</li><li>可以通使用analyze API测试字符串字段的映射(使用指定字段的分词设置)   </li></ul></li></ul></li></ol><h4 id="5-复杂核心域类型"><a href="#5-复杂核心域类型" class="headerlink" title="5. 复杂核心域类型"></a>5. 复杂核心域类型</h4><ol><li><p>多值域</p><ul><li>数组中所有值必须为同一类型</li><li>创建一个新字段，这个字段索引了一个数组，Elasticsearch将使用第一个值的类型来确定这个新字段的类型</li></ul></li><li><p>空域(这四个字段将被识别为空字段而不被索引)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;empty_string&quot;: &quot;&quot;,</span><br><span class="line">&quot;null_value&quot;: null,</span><br><span class="line">&quot;empty_array&quot;: [],</span><br><span class="line">&quot;array_with_null_value&quot;: [null]</span><br></pre></td></tr></table></figure></li><li><p>多层级对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tweet&quot;: &quot;Elasticsearch is very flexible&quot;,</span><br><span class="line">  &quot;user&quot;: &#123;</span><br><span class="line">    &quot;id&quot;: &quot;@johnsmith&quot;,</span><br><span class="line">    &quot;gender&quot;: &quot;male&quot;,</span><br><span class="line">    &quot;age&quot;: 26,</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">      &quot;full&quot;: &quot;John Smith&quot;,</span><br><span class="line">      &quot;first&quot;: &quot;John&quot;,</span><br><span class="line">      &quot;last&quot;: &quot;Smith&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部对象的映射(Elasticsearch会动态的检测新对象的字段，并且映射它们为<code>object</code>类型，将每个字段加到<code>properties</code>字段下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;gb&quot;: &#123;</span><br><span class="line">    &quot;tweet&quot;: &#123;</span><br><span class="line">      &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;tweet&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;,</span><br><span class="line">        &quot;user&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">          &quot;properties&quot;: &#123;</span><br><span class="line">            &quot;id&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;,                      </span><br><span class="line">            &quot;gender&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;,</span><br><span class="line">            &quot;age&quot;: &#123; &quot;type&quot;: &quot;long&quot; &#125;,</span><br><span class="line">            &quot;name&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;object&quot;,</span><br><span class="line">              &quot;properties&quot;: &#123;</span><br><span class="line">                &quot;full&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;,</span><br><span class="line">                &quot;first&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;,</span><br><span class="line">                &quot;last&quot;: &#123; &quot;type&quot;: &quot;string&quot; &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部对象是如何索引的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tweet&quot;: [elasticsearch, flexible, very],</span><br><span class="line">  &quot;user.id&quot;: [@johnsmith],</span><br><span class="line">  &quot;user.gender&quot;: [male],</span><br><span class="line">  &quot;user.age&quot;: [26],</span><br><span class="line">  &quot;user.name.full&quot;: [john, smith],</span><br><span class="line">  &quot;user.name.first&quot;: [john],</span><br><span class="line">  &quot;user.name.last&quot;: [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部对象数组是如何索引的(扁平化处理)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;followers&quot;:[&#123;&quot;age&quot;:35,&quot;name&quot;:&quot;Mary White&quot;&#125;,&#123;&quot;age&quot;:26,&quot;name&quot;:&quot;Alex Jones&quot;&#125;,&#123;&quot;age&quot;:19,&quot;name&quot;:&quot;Lisa Smith&quot;&#125;]</span><br><span class="line">&quot;followers.age&quot;: [19, 26, 35], &quot;followers.name&quot;: [alex, jones, lisa, smith, mary, white]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Elasticsearch笔记（一）&quot;&gt;&lt;a href=&quot;#Elasticsearch笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;Elasticsearch笔记（一）&quot;&gt;&lt;/a&gt;Elasticsearch笔记（一）&lt;/h2&gt;&lt;h3 id=&quot;一
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="database" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/"/>
    
      <category term="elasticsearch" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/database/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://huangdu.work/tags/elasticsearch/"/>
    
      <category term="非关系型数据库" scheme="https://huangdu.work/tags/%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>jvm内存模型笔记</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangdu.work/笔记/java/jvm内存模型/jvm内存模型笔记/</id>
    <published>2019-12-13T16:00:00.000Z</published>
    <updated>2019-12-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h2><h3 id="〇、概述"><a href="#〇、概述" class="headerlink" title="〇、概述"></a>〇、概述</h3><ul><li>JVM将其内存数据主要分为以下五个部分：</li><li>一、程序计数器</li><li>二、虚拟机栈</li><li>三、本地方法栈</li><li>四、Java堆</li><li>五、方法区</li></ul><h3 id="一、程序计数器"><a href="#一、程序计数器" class="headerlink" title="一、程序计数器"></a>一、程序计数器</h3><ul><li>程序计数器(Program Counter Register)是一块很小内存空间。</li><li>每一个线程有一个私有的程序计数器，用于记录下一条要运行的指令。  </li><li>如果当前线程正在执行一个Java方法，则程序计数器记录正在执行的Java字节码地址。</li><li>如果当前线程正在执行一个Native方法，则程序计数器为空。</li></ul><h3 id="二、Java虚拟机栈"><a href="#二、Java虚拟机栈" class="headerlink" title="二、Java虚拟机栈"></a>二、Java虚拟机栈</h3><ul><li>Java虚拟机栈也是线程私有的内存空间，它和Java线程在同一时间创建。</li><li>它保存方法的局部变量、部分结果，并参与方法的调用和返回。  </li><li>有两种异常与栈空间有关：<code>StackOverflowError</code>和<code>OutOfMemoryError</code>。</li><li>虚拟机栈在运行时使用一种叫做栈帧的数据结构保存上下文数据(其中存放了方法的局部变量表、操作数栈、动态连接方法和返回地址等信息)。</li><li>使用jclasslib工具可以对class文件做较为深入的研究。</li></ul><h3 id="三、本地方法栈"><a href="#三、本地方法栈" class="headerlink" title="三、本地方法栈"></a>三、本地方法栈</h3><ul><li>与Java虚拟机栈功能相似，Java虚拟机栈用于管理Java函数的调用，本地方法栈用于管理本地方法的调用。</li><li>在SUN的Hot Spot虚拟机中，不区分本地方法栈和虚拟机栈。</li></ul><h3 id="四、Java堆"><a href="#四、Java堆" class="headerlink" title="四、Java堆"></a>四、Java堆</h3><ul><li>Java堆是Java运行时内存中最为重要的部分，被JVM中所有线程共享，几乎所有的对象(数组也算对象)都是在堆中分配空间的。</li><li>Java堆分为新生代和老年代两个部分，新生代用于存放刚刚产生的对象和年轻的对象，如果对象一直没有被回收，生存得足够长，老年对象就会被移入老年代。</li><li>新生代又可进一步细分为eden(伊甸园)、survivor space0(s0或者from space)和survivor space1(s1或者to space)。</li><li>Full GC(<code>System.gc()</code>)后，新生代空间被清空，未被回收的对象全部被移入老年代。</li></ul><h3 id="五、方法区"><a href="#五、方法区" class="headerlink" title="五、方法区"></a>五、方法区</h3><ul><li>方法区也称为永久区，虽然叫做永久区，其中的对象也是可以被GC回收的。</li><li>方法区也是被JVM中所有线程共享，主要保存的信息是类的元数据(包括类的类型信息、常量池、域信息、方法信息)。</li><li>Hot Spot虚拟机对常量池的回收策略是明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</li><li>Hot Spot虚拟机确认某一个类信息不会被使用，也会将其回收。回收的基本条件至少有：所有该类的实例被回收，且装载该类的<code>ClassLoader</code>被回收。</li></ul><h3 id="六、jvm参数"><a href="#六、jvm参数" class="headerlink" title="六、jvm参数"></a>六、jvm参数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JVM参数</span></span><br><span class="line"><span class="comment"> * -client -server</span></span><br><span class="line"><span class="comment"> * -ea 开启assert断言机制</span></span><br><span class="line"><span class="comment"> * -verbose:gc 显示gc过程</span></span><br><span class="line"><span class="comment"> * -XX:+PrintGCDetails 显示gc详情</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:+UseSpinning 开启自旋锁</span></span><br><span class="line"><span class="comment"> * -XX:PreBlockSpin 设置自旋锁的等待次数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:+DoEscapeAnalysis 逃逸分析</span></span><br><span class="line"><span class="comment"> * -XX:+EliminateLocks 锁消除</span></span><br><span class="line"><span class="comment"> * -XX:-DoEscapeAnalysis 关闭逃逸分析</span></span><br><span class="line"><span class="comment"> * -XX:-EliminateLocks 关闭锁消除</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 虚拟机栈大小设置</span></span><br><span class="line"><span class="comment"> * -Xmx 最大堆内存   例-Xmx20M</span></span><br><span class="line"><span class="comment"> * -Xms 最小堆内存</span></span><br><span class="line"><span class="comment"> * -Xmn 设置新生代的大小</span></span><br><span class="line"><span class="comment"> * (-XX:NewSize 新生代初始值 -XX:MaxNewSize 新生代最大值 例-XX:NewSize=10M)</span></span><br><span class="line"><span class="comment"> * -XX:PermSize 方法区初始大小 -XX:MaxPermSize 方法区最大值</span></span><br><span class="line"><span class="comment"> * -Xss 设置线程栈的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio 新生代中 eden/s0 或 eden/s1(s0 和 s1大小相等)</span></span><br><span class="line"><span class="comment"> * -XX:NewRatio 老年代/新生代</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -XX:MinHeapFreeRatio 设置堆空间最小空闲比例</span></span><br><span class="line"><span class="comment"> * -XX:MaxHeapFreeRatio 设置堆空间最大空闲比例</span></span><br><span class="line"><span class="comment"> * -XX:TargetSurvivorRatio 设置survivor区的可使用率(当survivor区的空间使用率达到这个数值时，会将对象送入老年代)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> duhuang@iflytek.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 2019/12/14 11:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JvmDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;jvm内存模型&quot;&gt;&lt;a href=&quot;#jvm内存模型&quot; class=&quot;headerlink&quot; title=&quot;jvm内存模型&quot;&gt;&lt;/a&gt;jvm内存模型&lt;/h2&gt;&lt;h3 id=&quot;〇、概述&quot;&gt;&lt;a href=&quot;#〇、概述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="jvm内存模型" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/jvm%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jvm" scheme="https://huangdu.work/tags/jvm/"/>
    
      <category term="内存模型" scheme="https://huangdu.work/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之JUC和NIO篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/JUC%E5%92%8CNIO/6-java%E7%AC%94%E8%AE%B0%E4%B9%8BJUC%E5%92%8CNIO%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/JUC和NIO/6-java笔记之JUC和NIO篇/</id>
    <published>2019-11-12T16:00:00.000Z</published>
    <updated>2019-11-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二十七、JUC并发编程"><a href="#二十七、JUC并发编程" class="headerlink" title="二十七、JUC并发编程"></a>二十七、JUC并发编程</h2><h3 id="1-JUC简介"><a href="#1-JUC简介" class="headerlink" title="1. JUC简介"></a>1. JUC简介</h3><ul><li><code>java.util.concurrent</code>提供了并发访问工具支持</li><li><code>atomic</code>子包提供原子操作类</li><li><code>locks</code>子包实现各种锁机制</li></ul><h3 id="2-TimeUnit"><a href="#2-TimeUnit" class="headerlink" title="2. TimeUnit"></a>2. <code>TimeUnit</code></h3><ul><li>时间单元操作枚举类</li><li>可以实现时间单位的转换，并且方便地进行准确时间的休眠处理</li></ul><h3 id="3-原子操作类"><a href="#3-原子操作类" class="headerlink" title="3. 原子操作类"></a>3. 原子操作类</h3><ul><li>原子操作类可以保证在多线程并发访问下的数据安全，原子操作类中的数据内容都通过<code>volatile</code>关键字定义，为了进一步实现数据的计算准确性，又提供加法器与累加器的支持</li><li>基本类型：<br><code>AtomicInteger</code> <code>AtomicLong</code> <code>AtomicBoolean</code></li><li>数组类型：<br><code>AtomicIntegerArray</code> <code>AtomicLongArray</code> <code>AtomicReferenceArray</code></li><li>引用类型：<br><code>AtomicReference</code> <code>AtomicStampedReference</code> <code>AtomicMarkableReference</code></li><li>对象的属性修改类型：<ul><li><code>AtomicIntegerFieldUpdater</code></li><li><code>AtomicLongFieldUpdater</code></li><li><code>AtomicReferenceFieldUpdater</code></li></ul></li><li>CAS(Compare And Swap)是一条CPU并发原语，体现在<code>Unsafe</code>类中各个方法</li><li>累加器和加法器：<br><code>DoubleAccumulator</code> <code>LongAccumulator</code> <code>DoubleAdder</code> <code>LongAdder</code></li></ul><h3 id="4-ThreadFactory"><a href="#4-ThreadFactory" class="headerlink" title="4. ThreadFactory"></a>4. <code>ThreadFactory</code></h3><ul><li>依据此接口实现<code>Thread</code>类实例的统一管理，工厂设计模式</li></ul><h3 id="5-线程锁"><a href="#5-线程锁" class="headerlink" title="5. 线程锁"></a>5. 线程锁</h3><ul><li>AQS操作支持：<ul><li><code>AbstractOwnableSynchronizer</code></li><li><code>AbstractQueuedSynchronizer</code></li><li><code>AbstractLongSynchronizer</code></li></ul></li><li><code>Lock</code>接口：<code>ReentrantLock</code></li><li><code>ReadWriteLock</code>接口：<code>ReentrantReadWriterLock</code></li><li><code>StampedLock</code></li><li><code>Condition</code><ul><li><code>await()</code> <code>signal()</code> <code>signalAll()</code></li></ul></li><li><code>LockSupport</code><ul><li><code>park(...)</code> <code>unpark(...)</code></li></ul></li><li><code>Semaphore</code></li><li><code>CountDownLatch</code></li><li><code>CyclicBarrier</code></li><li><code>Exchanger</code></li><li><code>CompletableFuture</code></li></ul><h3 id="6-并发集合和阻塞队列"><a href="#6-并发集合和阻塞队列" class="headerlink" title="6. 并发集合和阻塞队列"></a>6. 并发集合和阻塞队列</h3><style>table th:nth-of-type(1){    width: 8%;}table th:nth-of-type(2){    width: 14%;}table th:nth-of-type(3){    width: 30%;}table th:nth-of-type(4){    width: 48%;}</style><table><thead><tr><th align="center">No.</th><th align="center">集合接口</th><th align="center">集合类</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">List</td><td align="center">CopyOnWriteArrayList</td><td align="left">相当于ArrayList</td></tr><tr><td align="center">2</td><td align="center">Set</td><td align="center">CopyOnWriteArraySet</td><td align="left">相当于HashSet 基于CopyOnWriteArrayList实现</td></tr><tr><td align="center">3</td><td align="center">Set</td><td align="center">ConcurrentSkipListSet</td><td align="left">相当于TreeSet 基于跳表结构实现</td></tr><tr><td align="center">4</td><td align="center">Map</td><td align="center">ConcurrentHashMap</td><td align="left">相当于HashMap</td></tr><tr><td align="center">5</td><td align="center">Map</td><td align="center">ConcurrentSkipListMap</td><td align="left">相当于TreeMap 基于跳表结构实现</td></tr><tr><td align="center">6</td><td align="center">Queue</td><td align="center">BlockingQueue</td><td align="left">阻塞队列: ArrayBlockingQueue LinkedBlockingQueue PriorityBlockingQueue SynchronousQueue</td></tr><tr><td align="center">7</td><td align="center">Queue</td><td align="center">ConcurrentLinkedQueue</td><td align="left">单向链表实现的无界队列 支持FIFO处理</td></tr><tr><td align="center">8</td><td align="center">Deque</td><td align="center">BlockingDeque</td><td align="left">阻塞队列：LinkedBlockingDeque</td></tr><tr><td align="center">9</td><td align="center">Deque</td><td align="center">ConcurrentLinkedDeque</td><td align="left">双向链表实现的无界队列 支持FIFO、FILO处理</td></tr><tr><td align="center">10</td><td align="center">Queue</td><td align="center">BlockingQueue</td><td align="left">延迟队列：DelayQueue (所保存元素需实现Delayed接口)</td></tr></tbody></table><h3 id="7-线程池"><a href="#7-线程池" class="headerlink" title="7. 线程池"></a>7. 线程池</h3><ul><li>线程池主要通过<code>Executors</code>类提供的方法创建，这些方法是对<code>ThreadPoolExecutor</code>类的封装</li><li>使用<code>ThreadPoolExecutor</code>类可以由用户传入自定义的阻塞队列与拒绝机制定制属于自己的特定线程池</li><li><code>CompletionService</code>提供有线程池中执行线程处理结果的异步接收操作</li></ul><h3 id="8-ForkJoinPool"><a href="#8-ForkJoinPool" class="headerlink" title="8. ForkJoinPool"></a>8. <code>ForkJoinPool</code></h3><ul><li>将一个复杂的业务拆分为若干个子业务，每个业务分别创建线程，这样可以实现较高的执行性能</li><li><code>ForkJoinPool</code>中需要通过<code>ForkJoinTask</code>定义执行任务</li><li><code>ForkJoinTask</code>有两个子类：<code>RecursiveTask</code>(有返回值任务) <code>RecursiveAction</code>(无返回值任务)</li><li><code>fork()</code>分解操作 <code>join()</code>合并操作</li></ul><h2 id="二十八、NIO编程"><a href="#二十八、NIO编程" class="headerlink" title="二十八、NIO编程"></a>二十八、NIO编程</h2><h3 id="1-NIO简介"><a href="#1-NIO简介" class="headerlink" title="1. NIO简介"></a>1. NIO简介</h3><ul><li>NIO采用Reactor模型实现了所有通道的集中管理，可以方便地使用缓冲区实现通道数据读/写</li></ul><h3 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. <code>Buffer</code></h3><ul><li>缓冲区<code>Buffer</code>提供有高性能的数据操作，可以通过position,limit,capacity表示缓冲区的操作状态</li><li>子类：<br><code>ByteBuffer</code> <code>CharBuffer</code> <code>ShortBuffer</code> <code>IntBuffer</code> <code>LongBuffer</code> <code>FloatBuffer</code> <code>DoubleBuffer</code></li><li><code>static allocate(...)</code> 创建指定容量的缓冲区</li><li><code>capacity()</code> <code>limit()</code> <code>position()</code> 获取缓冲区指针信息</li><li><code>put(...)</code> 缓冲区数据存放 <code>flip()</code> 准备输出</li><li><code>hasRemaining()</code> 是否有数据 <code>get()</code> 返回一个数据</li><li><code>clear()</code> 清空缓冲区</li></ul><h3 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. <code>Channel</code></h3><ul><li>通道可以用来读取和写入数据(操作缓冲区)，类似于之前的输入/输出流，但是程序不会直接操作通道，所有的内容都是先读取或写入缓冲区中，再通过缓冲区取得或写入</li><li>通道与传统的流操作不同，通道本身是双向操作的，既可以完成输入也可以完成输出</li><li><code>FileChannel</code>通道可以通过<code>FileInputStream</code>或<code>FileOutputStream</code>的<code>getChannel()</code>方法取得</li><li><code>Pipe</code> 线程管道<ul><li><code>static open()</code> 打开管道流</li><li><code>source()</code> 获得<code>Pipe.SourceChannel</code>接收管道数据</li><li><code>sink()</code> 获得<code>Pipe.SinkChannel</code>发送管道数据</li></ul></li></ul><h3 id="4-文件锁"><a href="#4-文件锁" class="headerlink" title="4. 文件锁"></a>4. 文件锁</h3><ul><li><code>FileChannel</code>可通过<code>tryLock()</code>操作获得<code>FileLock</code>实例锁定文件</li><li><code>FileLock</code>可使用<code>release()</code>方法释放</li></ul><h3 id="5-字符集"><a href="#5-字符集" class="headerlink" title="5. 字符集"></a>5. 字符集</h3><ul><li><code>Charset</code>类通过<code>forName(...)</code>指定编码实例化</li><li><code>newEncoder</code>创建编码器<code>CharsetEncoder</code>可使用<code>encode(...)</code>方法编码</li><li><code>newDecoder</code>创建解码器<code>CharsetDecoder</code>可使用<code>decode(...)</code>方法解码</li></ul><h3 id="6-同步非阻塞I-O通信模型"><a href="#6-同步非阻塞I-O通信模型" class="headerlink" title="6. 同步非阻塞I/O通信模型"></a>6. 同步非阻塞I/O通信模型</h3><ul><li><code>ServerSocketChannel</code> <code>SocketChannel</code></li></ul><h3 id="7-异步非阻塞I-O通信模型"><a href="#7-异步非阻塞I-O通信模型" class="headerlink" title="7. 异步非阻塞I/O通信模型"></a>7. 异步非阻塞I/O通信模型</h3><ul><li><code>AsynchronousServerSocketChannel</code> <code>AsynchronousSocketChannel</code></li><li><code>CompletionHandler</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二十七、JUC并发编程&quot;&gt;&lt;a href=&quot;#二十七、JUC并发编程&quot; class=&quot;headerlink&quot; title=&quot;二十七、JUC并发编程&quot;&gt;&lt;/a&gt;二十七、JUC并发编程&lt;/h2&gt;&lt;h3 id=&quot;1-JUC简介&quot;&gt;&lt;a href=&quot;#1-JUC简介&quot; c
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="JUC和NIO" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/JUC%E5%92%8CNIO/"/>
    
    
      <category term="JUC" scheme="https://huangdu.work/tags/JUC/"/>
    
      <category term="NIO" scheme="https://huangdu.work/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之常用API篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/%E5%B8%B8%E7%94%A8API/5-java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%B8%B8%E7%94%A8API%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/常用API/5-java笔记之常用API篇/</id>
    <published>2019-11-09T16:00:00.000Z</published>
    <updated>2019-11-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二十二、常用类库"><a href="#二十二、常用类库" class="headerlink" title="二十二、常用类库"></a>二十二、常用类库</h1><ol><li><code>StringBuffer</code>类<ul><li>在一个字符串内容需要频繁修改的时候，使用<code>StringBuffer</code>可以提升操作性能</li><li><code>StringBuffer</code>提供了大量的字符串操作方法：增加、替换、插入等</li><li><code>StringBuilder</code>与<code>StringBuffer</code>功能类似，但是它没有采用同步处理，线程不安全</li></ul></li><li><code>CharSequence</code>接口<ul><li><code>CharSequence</code>是一个字符串操作的公共接口</li><li>三个常见子类：<code>StringBuffer</code> <code>StringBuilder</code> <code>String</code></li></ul></li><li><code>AutoCloseable</code>接口<ul><li>提供有<code>close()</code>方法，主要实现资源的自动释放操作</li><li>需要结合<code>try-with-resource</code>机制使用</li></ul></li><li><code>Runtime</code>类<ul><li><code>Runtime</code>表示运行时，在一个jvm中只存在一个<code>Runtime</code></li><li>通过<code>Runtime</code>类的静态方法<code>getRuntim()</code>获得<code>Runtime</code>实例</li></ul></li><li><code>System</code>类<ul><li>系统类，可以取得系统的相关信息</li><li><code>System.gc()</code>可以提醒gc进行垃圾回收，实际上是调用了<code>Runtime</code>类中的<code>gc()</code>方法</li></ul></li><li><code>Cleaner</code>类<ul><li>jdk1.9之前对象回收释放的方法<code>finalize()</code></li><li>jdk1.9之后新的垃圾回收结构，可以避免对象回收时间过长导致的程序问题    </li></ul></li><li>对象克隆<ul><li>需要被克隆的类实现<code>Cloneable</code>接口，该接口属于没有任何方法的标识接口</li><li>克隆的实现可以使用<code>Object.clone()</code>完成</li></ul></li><li><code>Math</code>数学计算<ul><li>提供数学处理方法，内部方法均为<code>static</code></li><li><code>round()</code>方法进行四舍五入操作时只保留整数位</li></ul></li><li><code>Random</code>随机数<ul><li>可以取得指定范围的随机数字</li></ul></li><li>大数字处理类<ul><li>处理整型大数字可以使用<code>BigInteger</code></li><li>处理小数大数字可以使用<code>BigDecimal</code></li></ul></li><li><code>Date</code>日期处理类<ul><li>方便取得时间</li></ul></li><li><code>SimpleDateFormat</code>日期格式化<ul><li>可以进行日期的格式化操作</li><li><code>Format</code>是文本格式化操作类，共有三个子类：<code>DateFormat</code> <code>NumberFormat</code> <code>MessageFormat</code></li></ul></li><li>正则表达式<ul><li><code>String</code>类中的<code>replaceAll()</code> <code>split()</code> <code>matches()</code>方法都对正则提供支持</li><li><code>java.util.regex</code>包中的<code>Pattern</code> <code>Matcher</code>类</li></ul></li><li>国际化程序<ul><li>可以让一套程序业务逻辑在不同国家使用</li><li>需要利用资源文件、<code>Locale</code>、<code>ResourceBundle</code></li></ul></li><li><code>Arrays</code>数组操作类<ul><li>使用<code>Arrays.sort()</code>进行排序操作时必须使用比较器</li><li>比较器接口<code>Comparable</code>中定义了一个<code>compareTo()</code>的比较方法，用来设置比较规则(需要被指定类实现)</li><li>或者使用<code>Comparator</code>接口定义比较规则(可以用Lambda形式使用)</li></ul></li><li><code>UUID</code>无重复数据<ul><li>可以根据时间戳、硬件编号自动生成一个无重复的内容，该内容可以作为唯一编号使用</li></ul></li><li><code>Optional</code>空处理<ul><li>可以避免由于数据为<code>null</code>造成的<code>NullPointerException</code>问题</li></ul></li><li><code>ThreadLocal</code><ul><li>并发状态下的数据安全访问机制，每个线程对象只关心可以操作的数据</li><li>会由<code>ThreadLocal</code>帮助用户自行处理当前线程的保存与判断</li></ul></li><li>定时调度<ul><li>可以根据既定的时间安排实现程序任务的自动执行</li><li><code>TimerTask</code> <code>Timer</code></li></ul></li><li><code>Base64</code>加密与解密<ul><li>一种加密算法，利用合理的加密规则可以使得数据传输更加安全</li></ul></li></ol><h2 id="二十三、I-O编程"><a href="#二十三、I-O编程" class="headerlink" title="二十三、I/O编程"></a>二十三、I/O编程</h2><ol><li><code>File</code>文件操作<ul><li>创建、删除</li><li>利用递归操作子目录</li></ul></li><li>字节流与字符流<ul><li>字节流 <code>OutputStream</code> <code>InputStream</code></li><li>字符流 <code>Writer</code> <code>Reader</code>(用到缓冲区，适用于中文传输操作)</li><li>字节流与字符流的转换 <code>OutputStreamWriter</code> <code>InputStreamReader</code></li></ul></li><li>字符编码<ul><li>建议使用UTF-8编码</li><li><code>StandardCharsets</code>类定义了标准的编码格式</li></ul></li><li>文件操作流与内存操作流<ul><li>文件流<ul><li>字节流 <code>FileOutputStream</code> <code>FileInputStream</code></li><li>字符流 <code>FileWriter</code> <code>FileReader</code></li></ul></li><li>内存流<ul><li>字节流 <code>ByteArrayOutputStream</code> <code>ByteArrayInputStream</code></li><li>字符流 <code>CharArrayWriter</code> <code>CharArrayReader</code></li></ul></li></ul></li><li>管道流<ul><li>实现两个线程之间的通信，通信前要使用<code>connect()</code>方法进行管道连接</li><li><code>PipedOutputStream</code> <code>PipedWriter</code> <code>PipedInputStream</code> <code>PipedReader</code></li></ul></li><li>RandomAccessFile<ul><li>提供了灵活的数据访问模式，可以快速实现大文件数据部分内容的读取</li></ul></li><li>打印流<ul><li><code>PrintStream</code> <code>PrintWriter</code> 简化输出操作</li></ul></li><li>System类对I/O的支持<ul><li><code>System.out</code> 显示器的标准输出</li><li><code>System.err</code> 显示器的错误输出</li><li><code>System.in</code> 标准键盘输入</li></ul></li><li>BufferedReader缓冲输入流</li><li>Scanner输入流工具</li><li>对象序列化<ul><li>对象需要实现<code>Serializable</code>接口 <code>transient</code>关键字修饰的属性不会被序列化</li><li><code>ObjectOutputStream</code> <code>ObjectInputStream</code></li></ul></li></ol><h2 id="二十四、类集框架"><a href="#二十四、类集框架" class="headerlink" title="二十四、类集框架"></a>二十四、类集框架</h2><ol><li>java类集框架<ul><li>用来创建动态的对象数组操作</li><li>jdk1.5之后，类集框架采用泛型</li></ul></li><li><code>Collection</code>集合接口<ul><li>最大单值操作父接口</li></ul></li><li><code>List</code>集合<ul><li>内容允许重复</li><li><code>ArrayList</code> 数组实现集合</li><li><code>LinkedList</code> 链表实现集合</li><li><code>Vector</code> 早期集合类，所有操作方法都使用<code>synchronized</code>同步处理</li></ul></li><li><code>Set</code>集合<ul><li>内容不允许重复</li><li><code>HashSet</code> 散列存放，没有顺序(依靠<code>Object</code>类中的<code>equals()</code>和<code>hashCode()</code>方法来区分是否为同一对象)</li><li><code>TreeSet</code> 顺序存放(使用<code>Comparable</code>进行排序操作)</li></ul></li><li>集合输出<ul><li><code>Collection</code>接口继承<code>Iterable</code>接口</li><li><code>Iterable</code>接口中<code>iterator()</code>方法可以获取<code>Iterator</code>接口实例用于迭代</li><li>foreach的方式输出集合，其本质是通过<code>Iterable</code>接口中<code>iterator()</code>方法获取<code>Iterator</code>接口实例用于迭代</li><li>自定义类要使用foreach则必须实现<code>Iterable</code>接口</li><li><code>Vector</code>类可以使用<code>elements()</code>方法获取<code>Enumeration</code>接口进行内容输出(最早的迭代输出接口)</li><li><code>List</code>类可以使用<code>listIterator()</code>方法获取<code>ListIterator</code>接口进行双向输出操作，但是应该先执行由前向后的迭代再执行由后向前的迭代</li></ul></li><li><code>Map</code>集合<ul><li>可以存放二元偶对象数据，每一对数据都是一个<code>Map.Entry</code>接口实例</li><li><code>HashMap</code> 异步处理，性能较高 (散列存储，顺序不可控)</li><li><code>HashTable</code> 同步处理，性能较低</li><li><code>LinkedHashMap</code> (链式存储，顺序可控)</li><li><code>TreeMap</code> 可以按照key进行排序</li></ul></li><li><code>Stack</code>栈<ul><li><code>Vector</code>子类</li><li>入栈<code>push(E item)</code> 出栈<code>pop()</code></li></ul></li><li><code>Queue</code>队列<ul><li>单端队列，入队<code>offer(E e)</code> 出队<code>poll()</code></li><li><code>Deque</code>子接口 实现双端队列操作</li><li>实现类<ul><li><code>PriorityQueue</code>自动排序</li><li><code>LinkedList</code>链式</li><li><code>ArrayDeque</code>数组形式</li></ul></li></ul></li><li><code>Properties</code>属性操作<ul><li><code>HashTable</code>子类</li><li>只允许操作<code>String</code>类型数据，可以直接操作属性文件</li></ul></li><li><code>Collections</code>工具类<ul><li>提供将现有的集合转换为线程安全的集合的方法</li></ul></li><li><code>Stream</code><ul><li>数据流操作应用</li><li>结合Lambda表达式可以对集合中的数据进行过滤与数据统计处理</li></ul></li></ol><h2 id="二十五、网络编程"><a href="#二十五、网络编程" class="headerlink" title="二十五、网络编程"></a>二十五、网络编程</h2><ol><li>TCP是HTTP通信的基础，利用TCP可以实现可靠的数据传输服务</li><li>java中通过<code>ServerSocket</code>和<code>Socket</code>两个类实现了TCP协议封装</li><li>UDP属于数据报传送协议，采用的是不可靠的连接模式，即服务器端发送的消息内容客户端可能无法接收</li><li>java中使用<code>DatagramPacket</code>和<code>DatagramSocket</code>类完成UDP程序的开发</li></ol><h2 id="二十六、数据库编程"><a href="#二十六、数据库编程" class="headerlink" title="二十六、数据库编程"></a>二十六、数据库编程</h2><ol><li>JDBC提供了一套与平台无关的标准数据库操作接口和类，只要是支持java的数据库厂商，所提供的数据库只要依据此标准提供实现方法库就全部可以使用java语言进行数据库操作</li><li>JDBC属于服务，其标准操作步骤如下<ol><li>加载驱动程序：驱动程序由各个数据库生产商提供</li><li>连接数据库：<code>DriverManager.getConnection()</code>得到<code>Connection</code>(连接时要提供连接路径、用户名、密码) </li><li>实例化操作：通过<code>Connection</code>实例化<code>Statement</code> <code>PreparedStatement</code>对象</li><li>操作数据库：使用<code>Statement</code> <code>PreparedStatement</code>执行sql语句，如果是查询，则查询结果用<code>ResultSet</code>处理</li></ol></li><li>开发中不要使用<code>Statement</code>，而是要使用<code>PreparedStatement</code>，性能高且安全性高</li><li>JDBC2.0中提供的重要特性就是批处理操作，此操作可以让多条sql语句一次性执行完毕</li><li>事务控制可以在数据库更新时保证数据的一致性，主要方法为<code>Connection</code>提供的<code>setAutoCommit()</code> <code>commit()</code> <code>rollback()</code>方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二十二、常用类库&quot;&gt;&lt;a href=&quot;#二十二、常用类库&quot; class=&quot;headerlink&quot; title=&quot;二十二、常用类库&quot;&gt;&lt;/a&gt;二十二、常用类库&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;code&gt;StringBuffer&lt;/code&gt;类&lt;ul&gt;
&lt;li&gt;在一个字符
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="常用API" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/%E5%B8%B8%E7%94%A8API/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="API" scheme="https://huangdu.work/tags/API/"/>
    
      <category term="I/O" scheme="https://huangdu.work/tags/I-O/"/>
    
      <category term="集合" scheme="https://huangdu.work/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="网络编程" scheme="https://huangdu.work/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="TCP" scheme="https://huangdu.work/tags/TCP/"/>
    
      <category term="UDP" scheme="https://huangdu.work/tags/UDP/"/>
    
      <category term="JDBC" scheme="https://huangdu.work/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之反射机制篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/4-java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/反射机制/4-java笔记之反射机制篇/</id>
    <published>2019-11-01T16:00:00.000Z</published>
    <updated>2019-11-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二十一、反射机制"><a href="#二十一、反射机制" class="headerlink" title="二十一、反射机制"></a>二十一、反射机制</h2><h3 id="1-反射机制概述"><a href="#1-反射机制概述" class="headerlink" title="1. 反射机制概述"></a>1. 反射机制概述</h3><ul><li>重用性是面向对象设计的核心原则，为了进一步提升代码的重用性，java提供了反射机制</li><li>正操作：使用一个类一定要先导入程序所在的包，然后根据类进行对象实例化，依靠对象调用类的方法</li><li>反操作：根据实例化对象反推出其类型，即一个<code>Class</code>实例</li></ul><h3 id="2-Class类对象实例化"><a href="#2-Class类对象实例化" class="headerlink" title="2. Class类对象实例化"></a>2. <code>Class</code>类对象实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">String str = <span class="string">"Class类是反射机制的根源，以String为例"</span>;</span><br><span class="line"><span class="comment">// 1.通过Object类中所提供的getClass()方法获取</span></span><br><span class="line">Class&lt;?&gt; clazz1 = str.getClass();</span><br><span class="line"><span class="comment">// 2.通过“类型.class”形式获取(此方法可以获取八大基本类型的class)</span></span><br><span class="line">Class&lt;?&gt; clazz2 = String.class;</span><br><span class="line"><span class="comment">// 3.通过Class类的静态方法forName()获取，该方法可能会抛出ClassNotFoundException</span></span><br><span class="line">Class&lt;?&gt; clazz3 = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-反射实例化"><a href="#3-反射实例化" class="headerlink" title="3. 反射实例化"></a>3. 反射实例化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="comment">//相当于String str = new String();</span></span><br><span class="line"><span class="comment">//该方法只能够通过指定类的无参构造方法进行对象实例化，jdk1.9后设置为Deprecated</span></span><br><span class="line">String str1 = clazz.newInstance();</span><br><span class="line"><span class="comment">//jdk1.9后提倡的方式，根据参数类型获得指定构造方法进行实例化</span></span><br><span class="line">String str2 = clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">String str3 = clazz.getDeclaredConstructor(String.class).newInstance(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-反射机制与类操作"><a href="#4-反射机制与类操作" class="headerlink" title="4. 反射机制与类操作"></a>4. 反射机制与类操作</h3><ol><li><p>反射获取类结构信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="comment">// 1.获取包信息</span></span><br><span class="line">Package p = clazz.getPackage();</span><br><span class="line"><span class="comment">// 2.获取继承父类</span></span><br><span class="line">Class&lt;? <span class="keyword">super</span> String&gt; fatherClazz = clazz.getSuperclass();</span><br><span class="line"><span class="comment">// 3.获取实现接口</span></span><br><span class="line">Class&lt;?&gt;[] interfaces = clazz.getInterfaces();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException </span>&#123;</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="comment">// 一、获取构造方法Constructor</span></span><br><span class="line"><span class="comment">// 1.获取指定类中所有构造方法</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors1 = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="comment">// 2.获取指定类中所有public构造方法</span></span><br><span class="line">Constructor&lt;?&gt;[] constructors2 = clazz.getConstructors();</span><br><span class="line"><span class="comment">// 3.获取指定类中指定参数类型的构造方法</span></span><br><span class="line">Constructor&lt;?&gt; constructor1 = clazz.getDeclaredConstructor(<span class="keyword">char</span>[].class, <span class="keyword">boolean</span>.class);</span><br><span class="line"><span class="comment">// 4.获取指定类中指定参数类型的public构造方法</span></span><br><span class="line">Constructor&lt;?&gt; constructor2 = clazz.getConstructor(String.class);</span><br><span class="line"><span class="comment">// 二、Constructor类常用方法</span></span><br><span class="line"><span class="comment">// 1.调用构造方法传入指定参数进行对象实例化</span></span><br><span class="line">String instance = (String) constructor2.newInstance(<span class="string">"hello"</span>);</span><br><span class="line"><span class="comment">// 2.获取构造方法名称</span></span><br><span class="line">String name = constructor2.getName();</span><br><span class="line"><span class="comment">// 3.获取构造方法的参数类型</span></span><br><span class="line">Class&lt;?&gt;[] parameterClazzs = constructor2.getParameterTypes();</span><br><span class="line">Type[] parameterTypes = constructor2.getGenericParameterTypes();</span><br><span class="line"><span class="comment">// 4.获取构造方法抛出的异常类型</span></span><br><span class="line">Class&lt;?&gt;[] exceptionClazzs = constructor2.getExceptionTypes();</span><br><span class="line">Type[] exceptionTypes = constructor2.getGenericExceptionTypes();</span><br><span class="line"><span class="comment">// 5.获取构造方法的参数个数</span></span><br><span class="line"><span class="keyword">int</span> parameterCount = constructor2.getParameterCount();</span><br><span class="line"><span class="comment">// 6.设置构造方法可见性，可使用私有构造方法</span></span><br><span class="line">constructor2.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 7.获取注解(省略)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="comment">// 获取方法Mehod</span></span><br><span class="line"><span class="comment">// 1.获取指定类中所有方法(不包括继承的)</span></span><br><span class="line">Method[] methods1 = clazz.getDeclaredMethods();</span><br><span class="line"><span class="comment">// 2.获取指定类中所有public方法(包括继承的)</span></span><br><span class="line">Method[] methods2 = clazz.getMethods();</span><br><span class="line"><span class="comment">// 3.获取指定类中指定名称，指定参数类型的方法(不包括继承的)</span></span><br><span class="line">Method method1 = clazz.getDeclaredMethod(<span class="string">"indexOf"</span>, String.class);</span><br><span class="line"><span class="comment">// 4.获取指定类中指定名称，指定参数类型的public方法(包括继承的)</span></span><br><span class="line">Method method2 = clazz.getMethod(<span class="string">"chars"</span>);</span><br><span class="line"><span class="comment">// Method类常用方法</span></span><br><span class="line"><span class="comment">// 1.方法调用，等价于“实例化对象.方法()”</span></span><br><span class="line"><span class="keyword">int</span> returnValue = (<span class="keyword">int</span>) method1.invoke(<span class="string">"Hello World!"</span>, <span class="string">"World"</span>);</span><br><span class="line"><span class="comment">// 2.获取方法返回值类型</span></span><br><span class="line">Class&lt;?&gt; returnClazz = method1.getReturnType();</span><br><span class="line"><span class="comment">// 3.获取方法名称</span></span><br><span class="line">String name = method1.getName();</span><br><span class="line"><span class="comment">// 4.获取方法的参数类型</span></span><br><span class="line">Class[] parameterClazzs = method1.getParameterTypes();</span><br><span class="line">Type[] parameterTypes = method1.getGenericParameterTypes();</span><br><span class="line"><span class="comment">// 5.获取方法抛出的异常类型</span></span><br><span class="line">Class[] exceptionClazzs = method1.getExceptionTypes();</span><br><span class="line">Type[] exceptionTypes = method1.getGenericExceptionTypes();</span><br><span class="line"><span class="comment">// 6.获取方法的参数个数</span></span><br><span class="line"><span class="keyword">int</span> parameterCount = method1.getParameterCount();</span><br><span class="line"><span class="comment">// 7.设置方法可见性，可使用私有方法</span></span><br><span class="line">method1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 8.获取方法修饰符 见Modifier类</span></span><br><span class="line"><span class="keyword">int</span> modifiers = method1.getModifiers();</span><br><span class="line"><span class="comment">// 9.获取注解(省略)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射调用成员属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">Class&lt;String&gt; clazz = String.class;</span><br><span class="line"><span class="comment">// 获取成员属性Field</span></span><br><span class="line"><span class="comment">// 1.获取指定类中所有属性(不包括继承的)</span></span><br><span class="line">Field[] fields1 = clazz.getDeclaredFields();</span><br><span class="line"><span class="comment">// 2.获取指定类中所有public属性(包括继承的)</span></span><br><span class="line">Field[] fields2 = clazz.getFields();</span><br><span class="line"><span class="comment">// 3.获取指定类中指定属性名称的属性(不包括继承的)</span></span><br><span class="line">Field field1 = clazz.getDeclaredField(<span class="string">"hash"</span>);</span><br><span class="line"><span class="comment">// 4.获取指定类中指定属性名称的public属性(包括继承的)</span></span><br><span class="line">Field field2 = clazz.getField(<span class="string">"CASE_INSENSITIVE_ORDER"</span>);</span><br><span class="line"><span class="comment">// Field类常用属性</span></span><br><span class="line"><span class="comment">// 1.获取成员属性名</span></span><br><span class="line">String name = field1.getName();</span><br><span class="line"><span class="comment">// 2.获取成员属性类型</span></span><br><span class="line">Class&lt;?&gt; type = field1.getType();</span><br><span class="line"><span class="comment">// 3.设置成员属性可见性，可使用私有属性</span></span><br><span class="line">field1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 4.设置成员属性内容</span></span><br><span class="line">Object obj = <span class="string">"Hello"</span>;</span><br><span class="line">field1.set(obj, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 5.获取成员属性内容</span></span><br><span class="line"><span class="keyword">int</span> value = (<span class="keyword">int</span>) field1.get(obj);</span><br><span class="line"><span class="comment">// 6.获取成员属性修饰符 见Modifier类</span></span><br><span class="line"><span class="keyword">int</span> modifiers = field1.getModifiers();</span><br><span class="line"><span class="comment">// 7.获取注解(省略)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>Unsafe</code>工具类</p><ul><li>java中的<code>Unsafe</code>类为我们提供了类似C++手动管理内存的能力</li><li>从名字中我们可以看出来这个类对普通程序员来说是危险的，一般应用开发者不会用到这个类<br><img src="/images/blog/Unsafe%E7%B1%BB%E5%8A%9F%E8%83%BD.png" alt="Unsafe类功能" title="Unsafe类功能"></li><li>扩展链接：<br><a href="https://www.jianshu.com/p/db8dce09232d" title="Java中的Unsafe" target="_blank" rel="noopener">Java中的Unsafe</a><br><a href="https://www.cnblogs.com/throwable/p/9139947.html" title="JAVA中神奇的双刃剑--Unsafe" target="_blank" rel="noopener">JAVA中神奇的双刃剑–Unsafe</a></li></ul></li></ol><h3 id="5-ClassLoader类加载器"><a href="#5-ClassLoader类加载器" class="headerlink" title="5. ClassLoader类加载器"></a>5. <code>ClassLoader</code>类加载器</h3><ul><li><p>JVM解释的程序类需要通过类加载器进行加载后才可以执行，为了保证java程序的执行安全性，JVM提供有3种类加载器</p><ul><li>Bootstrap(根加载器 系统类加载器) C++编写，加载java底层系统类库</li><li>PlatformClassLoader(平台类加载器) jdk1.8以前为ExtClassLoader，主要进行模块功能加载</li><li>AppClassLoader(应用程序类加载器) 加载CLASSPATH指定的类文件或者JAR文件</li></ul></li><li><p>获取<code>ClassLoader</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"String类由系统类加载器加载."</span>;</span><br><span class="line"><span class="comment">// 系统类加载器非java编写，所以只能以null结果返回</span></span><br><span class="line">System.out.println(str.getClass().getClassLoader());</span><br><span class="line"><span class="comment">// 自定义类由AppClassLoader加载，可通过getParent()获取其父类加载器</span></span><br><span class="line">ClassLoaderDemo demo=<span class="keyword">new</span> ClassLoaderDemo();</span><br><span class="line">System.out.println(demo.getClass().getClassLoader());</span><br><span class="line">System.out.println(demo.getClass().getClassLoader().getParent());</span><br><span class="line">System.out.println(demo.getClass().getClassLoader().getParent().getParent());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义<code>ClassLoader</code><ul><li>继承<code>ClassLoader</code></li><li>使用<code>ClassLoader</code>提供的<code>defineClass()</code>方法可将二进制数据文件加载为类</li><li>自定义加载器为AppClassLoader的子类加载器</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二十一、反射机制&quot;&gt;&lt;a href=&quot;#二十一、反射机制&quot; class=&quot;headerlink&quot; title=&quot;二十一、反射机制&quot;&gt;&lt;/a&gt;二十一、反射机制&lt;/h2&gt;&lt;h3 id=&quot;1-反射机制概述&quot;&gt;&lt;a href=&quot;#1-反射机制概述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="反射机制" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="反射机制" scheme="https://huangdu.work/tags/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    
      <category term="Unsafe" scheme="https://huangdu.work/tags/Unsafe/"/>
    
      <category term="ClassLoader" scheme="https://huangdu.work/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之多线程篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3-java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/多线程/3-java笔记之多线程篇/</id>
    <published>2019-10-27T16:00:00.000Z</published>
    <updated>2019-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二十、多线程编程"><a href="#二十、多线程编程" class="headerlink" title="二十、多线程编程"></a>二十、多线程编程</h2><h3 id="1-线程基本知识"><a href="#1-线程基本知识" class="headerlink" title="1. 线程基本知识"></a>1. 线程基本知识</h3><ul><li>线程与进程<ul><li>进程：程序的一次动态执行过程</li><li>线程：轻量级的进程，线程本身不能单独运行，必须放在一个进程中才能执行</li></ul></li><li>java的线程模型(线程五种状态)<br><img src="/images/blog/java%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81.jpg" alt="java线程的五种状态" title="java线程的五种状态"><ol><li>新建状态(New)<ul><li>线程被创建之后便处于新建状态</li></ul></li><li>就绪状态(Runnable)<ul><li>新建状态的线程调用<code>start()</code>进入就绪状态</li><li>阻塞状态的线程解除阻塞之后进入就绪状态</li></ul></li><li>运行状态(Running)<ul><li>处于就绪状态的线程获得了CPU的资源，该线程就进入了运行状态</li></ul></li><li>阻塞状态(Blocked)<ul><li>是一个正在运行的线程，在某些特殊情况下让出CPU资源暂时中止而进入的状态</li><li>人为挂起、需要运行耗时的输入或输出操作</li><li><code>sleep()</code> <code>suspend()</code> <code>wait()</code></li></ul></li><li>终止状态(Dead)<ul><li>处于终止状态的线程不具有继续运行的能力</li><li>正常终止</li><li>强制终止：<code>stop()</code> <code>destroy()</code> <code>System.exit(0)</code></li><li>异常终止：当线程执行过程中产生了异常，线程会终止</li></ul></li></ol></li></ul><h3 id="2-创建线程的方式"><a href="#2-创建线程的方式" class="headerlink" title="2. 创建线程的方式"></a>2. 创建线程的方式</h3><ol><li>继承<code>Thread</code>类<ul><li>继承<code>Thread</code>类，重写<code>run()</code>方法，调用<code>start()</code>方法执行线程</li></ul></li><li>实现<code>Runnable</code>接口<ul><li>实现<code>Runnable</code>接口，实现<code>run()</code>方法，作为参数构造<code>Thread</code>对象，调用<code>start()</code>方法执行线程</li><li><code>Runnable</code>为函数接口支持Lambda表达式</li></ul></li><li>实现<code>Callable</code>接口<ul><li>实现<code>Callable</code>接口，实现<code>call()</code>方法，可以有返回值</li><li><code>Callable</code>接口可以设置一个泛型，即<code>call()</code>方法返回数据类型</li><li><code>FutureTask</code>类常用方法(其实现了<code>RunnableFuture</code>接口)<ul><li><code>FutureTask(Callabel&lt;V&gt; c)</code> 接收<code>Callable</code>接口实例</li><li><code>FutureTask(Runnable r, V r)</code> 接收<code>Runnable</code>接口实例，并指定返回结果类型</li><li><code>V get()</code> 取得线程操作结果，此方法为<code>Future</code>接口定义</li></ul></li><li>将<code>Callable</code>接口对象作为参数构造<code>FutureTask</code>对象，再将<code>FutureTask</code>对象作为参数构造<code>Thread</code>对象，调用<code>start()</code>方法执行线程</li><li>当线程执行完毕后可调用<code>FutureTask</code>对象<code>get()</code>方法获取线程的执行结果</li></ul></li><li><code>Thread</code> <code>Runnable</code> <code>Callable</code>的比较<ul><li>因为java是单继承，继承<code>Thread</code>类限制较大</li><li>从结构上说<code>Thread</code>描述的是线程对象，<code>Runnable</code>定义的是并发资源</li><li><code>Runnable</code>是在jdk1.0后提出的，<code>Callable</code>是在jdk1.5后提出的</li><li><code>Runnable</code>提供一个<code>run()</code>方法，并且没有返回值</li><li><code>Callable</code>提供一个<code>call()</code>方法，可以有返回值(通过<code>Future</code>接口获取)</li></ul></li><li>线程池<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService threadPool=Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">threadPool.execute(runn);<span class="comment">//runn是Runnable子类</span></span><br><span class="line">threadPool.shutdown();</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-多个线程并发执行"><a href="#3-多个线程并发执行" class="headerlink" title="3. 多个线程并发执行"></a>3. 多个线程并发执行</h3><ul><li>java对于线程启动后唯一能保证的是每个线程都被启动并且结束</li><li>但是对于哪个线程先执行，哪个后执行，什么时候执行，是没有保证的</li></ul><h3 id="4-Thread常用方法"><a href="#4-Thread常用方法" class="headerlink" title="4. Thread常用方法"></a>4. <code>Thread</code>常用方法</h3><ol><li><code>static Thread currentThread()</code> 可以获取运行该方法的线程</li><li><strong>*</strong> <code>static void sleep(long ms)</code> 休眠方法，该方法可以将运行该方法的线程阻塞指定毫秒</li><li><strong>*</strong> <code>static void yield()</code> 暂停方法，释放调用该方法的线程的CPU资源，大家一起来抢(包括自己)</li><li><strong>*</strong> <code>void join()</code> 挂起方法，等待调用该方法的线程终止后再继续执行</li><li><code>void setPriority(int newPriority)</code> 设置线程优先级，java中优先级高的线程有更大的可能性获得CPU，但不是优先级高的总是先执行，也不是优先级低的线程总是后执行</li><li><code>void setDaemon(boolean on)</code> 设置守护线程(后台线程)，当一个进程中的所有前台进程都结束时，进程结束，无论该进程中的守护线程是否还在运行都要强制将它们结束(GC线程就属于一个守护线程)</li><li>其它<code>getId()</code> <code>getName()</code> <code>getPriority()</code> <code>isDaemon()</code> <code>isAlive()</code> <code>isInterrupted()</code> <code>start()</code> <code>interrupt()</code></li><li><strong>*</strong> 为线程调度三个方法</li></ol><h3 id="5-线程同步问题的由来"><a href="#5-线程同步问题的由来" class="headerlink" title="5. 线程同步问题的由来"></a>5. 线程同步问题的由来</h3><ul><li>线程同步问题的由来<ul><li>多个线程共享资源并没有进行控制</li><li>当多个线程并发访问同一资源时，由于线程切换时机不确定导致执行代码顺序的混乱，从而出现执行未按程序设计顺序运行导致出现各种错误，严重时可能导致系统瘫痪</li></ul></li><li>同步问题java的解决方案<ul><li>同步方法<ul><li><code>synchronized 方法声明{}</code></li><li>当线程进入同步方法的时候，会获得同步方法所属对象的锁</li><li>一旦获得对象锁，则其他线程不能再执行被锁对象的其他任何同步方法，只有在同步方法执行完毕之后释放了锁，其他线程才能继续执行</li></ul></li><li>同步块(比同步方法更细粒度)<ul><li><code>synchronized(资源对象){//需要进行同步的方法}</code></li><li>当线程进入同步块的时候，会获得同步块所属对象的锁</li><li>一旦获得对象锁，则其他线程不能再执行被锁对象的该同步块，只有在同步块执行完毕之后释放了锁，其他线程才能继续执行</li></ul></li><li>使用<code>Lock</code>类<ul><li>创建方法 <code>private Lock lock = new ReentrantLock();</code></li><li>常用方法 <code>lock()</code> <code>tryLock()</code> <code>unlock()</code> <code>Condition</code> <code>newCondition()</code> <code>await()</code> <code>signal()</code> <code>signalAll()</code></li></ul></li></ul></li><li><code>StringBuiler</code>不是线程安全的，当多个线程操作同一个字符串时应当使用<code>StringBuffer</code></li><li>常用的集合实现类：<code>ArrayList</code> <code>LinkedList</code> <code>HashSet</code>它们都不是线程安全的<ul><li><code>Collections</code>可以将现有的集合转换为线程安全的</li><li>例：<code>listName=Collections.synchronizedList(listName);</code></li></ul></li></ul><h3 id="6-死锁问题"><a href="#6-死锁问题" class="headerlink" title="6. 死锁问题"></a>6. 死锁问题</h3><ul><li>例：A线程需要申请资源1才能继续执行，而资源1被B线程所占有；B线程需要申请资源2才能继续执行，而资源2被A线程所占有</li></ul><h3 id="7-生产者和消费者模型"><a href="#7-生产者和消费者模型" class="headerlink" title="7. 生产者和消费者模型"></a>7. 生产者和消费者模型</h3><ul><li><p>永远在<code>while</code>循环中对条件进行判断而不是<code>if</code>语句中进行<code>wait()</code>条件的判断</p></li><li><p>使用<code>notifyAll()</code>而不是使用<code>notify()</code></p></li><li><p>了解对象锁与类锁</p></li><li><p>使用同步块的生产者消费者模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList();<span class="comment">//仓库</span></span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">100</span>;<span class="comment">//仓库大小</span></span><br><span class="line">        Producer p=<span class="keyword">new</span> Producer(<span class="string">"生产者"</span>,max,list);</span><br><span class="line">        Consumer c=<span class="keyword">new</span> Consumer(<span class="string">"消费者"</span>,max,list);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(p::produce).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c::consume).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生产者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(String userName,<span class="keyword">int</span> max,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName=userName;</span><br><span class="line">        <span class="keyword">this</span>.max=max;</span><br><span class="line">        <span class="keyword">this</span>.list=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">while</span>(list.size()&gt;=max)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"当前仓库产品数量:"</span>+list.size()+<span class="string">",仓库满了.生产者等待."</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> product=(<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>)+<span class="number">1</span>;</span><br><span class="line">                list.add(product);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.userName+<span class="string">"生产了产品:"</span>+product+<span class="string">",当前仓库产品数量:"</span>+list.size());</span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(String userName,<span class="keyword">int</span> max,List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName=userName;</span><br><span class="line">        <span class="keyword">this</span>.max=max;</span><br><span class="line">        <span class="keyword">this</span>.list=list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                <span class="keyword">while</span>(list.isEmpty())&#123;</span><br><span class="line">                    System.out.println(<span class="string">"仓库空了,消费者等待."</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        list.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> goods=list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.userName+<span class="string">"消费了商品:"</span>+goods+<span class="string">",当前仓库产品数量:"</span>+list.size());</span><br><span class="line">                list.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Lock</code>类的生产者消费者模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition empty = lock.newCondition();</span><br><span class="line">        Condition full = lock.newCondition();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList();<span class="comment">//仓库</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1000</span>;<span class="comment">//仓库大小</span></span><br><span class="line">        Producer2 p = <span class="keyword">new</span> Producer2(<span class="string">"生产者"</span>, max, list, lock, empty, full);</span><br><span class="line">        Consumer2 c = <span class="keyword">new</span> Consumer2(<span class="string">"消费者"</span>, max, list, lock, empty, full);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(p::produce).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c::consume).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生产者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition empty;</span><br><span class="line">    <span class="keyword">private</span> Condition full;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer2</span><span class="params">(String userName, <span class="keyword">int</span> max, List&lt;Integer&gt; list, Lock lock, Condition empty, Condition full)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.empty = empty;</span><br><span class="line">        <span class="keyword">this</span>.full = full;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (list.size() &gt;= max) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"当前仓库产品数量:"</span> + list.size() + <span class="string">",仓库满了.生产者等待."</span>);</span><br><span class="line">                    full.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> product = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>) + <span class="number">1</span>;</span><br><span class="line">                list.add(product);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.userName + <span class="string">"生产了产品:"</span> + product + <span class="string">",当前仓库产品数量:"</span> + list.size());</span><br><span class="line">                empty.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消费者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> Lock lock;</span><br><span class="line">    <span class="keyword">private</span> Condition empty;</span><br><span class="line">    <span class="keyword">private</span> Condition full;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer2</span><span class="params">(String userName, <span class="keyword">int</span> max, List&lt;Integer&gt; list, Lock lock, Condition empty, Condition full)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.empty = empty;</span><br><span class="line">        <span class="keyword">this</span>.full = full;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"仓库空了,消费者等待."</span>);</span><br><span class="line">                    empty.await();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> goods = list.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.userName + <span class="string">"消费了商品:"</span> + goods + <span class="string">",当前仓库产品数量:"</span> + list.size());</span><br><span class="line">                full.signalAll();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-优雅的停止线程"><a href="#8-优雅的停止线程" class="headerlink" title="8. 优雅的停止线程"></a>8. 优雅的停止线程</h3><ul><li><code>suspend()</code> <code>resume()</code> <code>stop()</code> 三个方法从jdk1.2开始不推荐使用，因为会产生死锁问题</li><li>优雅的停止一个线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">50</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(num++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//如果想让线程停止只需要将flag设置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-volatile关键字"><a href="#9-volatile关键字" class="headerlink" title="9. volatile关键字"></a>9. <code>volatile</code>关键字</h3><ul><li>多线程操作公共的普通变量时，往往是复制相应的副本，操作完成后再将此副本变量数据与原始变量进行同步处理</li><li>使用<code>volatile</code>关键字声明变量，可以直接进行原始变量的操作</li><li><code>volatile</code>关键字不是描述同步的操作，而是可以更快捷地进行原始变量的访问，避免了副本创建与数据同步处理</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二十、多线程编程&quot;&gt;&lt;a href=&quot;#二十、多线程编程&quot; class=&quot;headerlink&quot; title=&quot;二十、多线程编程&quot;&gt;&lt;/a&gt;二十、多线程编程&lt;/h2&gt;&lt;h3 id=&quot;1-线程基本知识&quot;&gt;&lt;a href=&quot;#1-线程基本知识&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="多线程" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="多线程" scheme="https://huangdu.work/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="生产者和消费者模型" scheme="https://huangdu.work/tags/%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="线程同步问题" scheme="https://huangdu.work/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/"/>
    
      <category term="volatile" scheme="https://huangdu.work/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之面向对象篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2-java%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/面向对象/2-java笔记之面向对象篇/</id>
    <published>2019-10-25T16:00:00.000Z</published>
    <updated>2019-11-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="九、类的基础"><a href="#九、类的基础" class="headerlink" title="九、类的基础"></a>九、类的基础</h2><ol><li><p>类的概述</p><ul><li>类就是事物的集合和抽象，它所代表的是这类事物所共有的一些行为和属性</li></ul></li><li><p>类的一般形式</p><ul><li>类是由属性(成员变量Field)和行为(方法Method)构成</li><li>类的定义<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] <span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">    成员变量;</span><br><span class="line">    方法(包括构造方法);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象的创建和使用</p><ul><li>对象是类的实例</li><li>创建 <code>类名称 对象名称=new 类名称();</code></li><li>使用 <code>对象.成员变量</code> <code>对象.方法()</code></li><li>匿名对象的创建使用(没用引用) <code>new 类名称().方法()</code></li></ul></li><li><p>对象类型的参数传递</p><ul><li>java中只有值传递 (引用类型存储的值是地址，存储在<strong>栈内存</strong>)</li><li>引用类型作为参数，操作的是引用指向的<strong>堆内存</strong>中的对象</li><li>GC(Garbage Collection)会不定期的对没有用的对象进行清理</li></ul></li><li><p>方法</p><ul><li>如果方法没有返回值，则必须写<code>void</code>不能省略</li><li>如果有返回值，则定义的方法的类型必须和方法体内返回值的类型相同</li><li><code>private static void main(String[] args){}</code>主方法(程序的入口)</li><li>方法递归调用：<ul><li>递归调用指的是方法调用自己的特殊调用形式</li><li>递归调用必须有结束条件</li><li>每次调用的时候都需要根据需求改变传递的参数内容</li></ul></li></ul></li><li><p>构造方法</p><ul><li>作用是用于初始化参数</li><li>当没有写构造方法时，编译器会默认加上无参构造方法</li><li>写了构造方法时，编译器不会默认加上无参构造方法</li><li><code>this(参数列表);</code>调用本类其它构造器(只能调用一个构造方法且必须位于开始)</li><li><code>super(参数列表);</code>调用父类构造器(只能调用一个构造方法且必须位于开始)</li><li>构造方法的递归调用是不允许的</li></ul></li><li><p><code>this</code>和<code>super</code>对比</p><table><thead><tr><th align="center">No.</th><th align="center">对比</th><th align="center">this</th><th align="center">super</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">定义</td><td align="center">表示本类对象</td><td align="center">表示父类对象</td></tr><tr><td align="center">2</td><td align="center">使用</td><td align="center">本类操作：<code>this.属性</code> <code>this.方法</code> <code>this()</code></td><td align="center">父类操作：<code>super.属性</code> <code>super.方法</code> <code>super()</code></td></tr><tr><td align="center">3</td><td align="center">调用构造</td><td align="center">调用本类构造，要放在首行</td><td align="center">子类调用父类构造，要放在首行</td></tr><tr><td align="center">4</td><td align="center">查找范围</td><td align="center">先从本类查找，找不到查找父类</td><td align="center">直接由子类查找父类</td></tr><tr><td align="center">5</td><td align="center">特殊</td><td align="center">表示当前对象</td><td align="center">——</td></tr></tbody></table></li><li><p>方法的重载</p><ul><li>发生在一个类中，方法名称相同，参数列表不同(参数类型不同、参数数量不同、参数次序不同)</li><li>编译器在编译时会根据方法签名(方法名+参数列表)自动绑定调用的方法</li><li>考虑到标准性重载方法一般都建议统一返回值类型</li><li>构造方法也可以重载</li></ul></li><li><p><code>static</code>关键字</p><ul><li>静态变量<ul><li>静态变量是属于类的，和对象没有关系</li><li>非静态变量是属于某个对象的，每个对象都有该数据的副本，而静态变量只有一个</li><li>非静态变量保存在堆内存中，而静态变量保存在全局数据区</li><li>访问静态变量可通过(类名.变量名)来访问的</li></ul></li><li>静态方法<ul><li>用<code>static</code>修饰的方法称为静态方法</li><li>访问静态方法可通过(类名.方法名)</li><li>静态方法不能访问非静态变量和方法，非静态方法可以访问静态变量和方法</li><li>静态属性和方法是在类加载的时候产生的，非静态属性和方法是在new的时候产生的</li></ul></li></ul></li><li><p><code>final</code>关键字</p><ul><li>使用<code>final</code>修饰过的都是不可改变的</li><li><code>final</code>修饰变量：不可被重新赋值，变量名建议全部大写</li><li><code>final</code>修饰方法：不可被重写，重载不会受到限制</li><li><code>final</code>修饰类：不可被继承，该类不能作为任何类的父类</li><li>静态常量 <code>public static final 类型 变量名=值;</code></li></ul></li><li><p>代码块</p><ul><li>程序中使用<code>{}</code>定义起来的一段程序</li><li>普通代码块：<ul><li>定义在方法中的代码块</li><li>可以将一个方法中的代码进行部分分割</li><li>每一个普通代码块中的局部变量不会对外面产生影响</li></ul></li><li>同步代码块：<ul><li>定义在方法中加<code>synchronized(同步对象)</code>的代码块</li><li>代码块在同一个时间段内，只允许一个线程执行操作</li><li>同步对象的选择会对其产生影响</li></ul></li><li>构造代码块：<ul><li>定义在类中的代码块</li><li><strong>每一次</strong>实例化对象的时候执行</li><li>构造代码块的执行优先于构造方法</li></ul></li><li>静态代码块：<ul><li>定义在类中加<code>static</code>的代码块</li><li><strong>第一次</strong>实例化对象的时候执行</li><li>静态代码块的执行优先于构造代码块</li></ul></li></ul></li></ol><h2 id="十、面向对象三大特征"><a href="#十、面向对象三大特征" class="headerlink" title="十、面向对象三大特征"></a>十、面向对象三大特征</h2><ol><li><p>封装</p><ul><li>类：封装对象的属性和行为</li><li>方法：封装了具体的业务逻辑功能行为</li><li>访问控制修饰符：封装的具体的访问权限(属性私有化，方法公开化)</li></ul></li><li><p>继承</p><ul><li><p>实现代码的复用，减少代码的重复</p></li><li><p><code>extends</code>只能继承一个类，java不支持多重继承，但可以<code>implements</code>实现多个接口</p></li><li><p>子类继承父类之后，子类可以调用父类的属性和方法(传递性)，也可以重写父类的方法，覆盖父类的属性，还可以增加自己的属性和方法</p></li><li><p>重写</p><ul><li>重写方法被调用时，看对象的类型，遵循运行期绑定</li><li>遵循”两同两小一大”原则：<ul><li>发生在父子类中，方法名称相同，参数列表相同，方法体不同</li><li>子类方法返回值类型应比父类方法返回值类型更小或相等(父类<code>double</code>子类<code>int</code>不行)</li><li>子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等</li><li>子类方法的访问权限应比父类方法的访问权限更大或相等</li></ul></li><li>父类<code>private</code>或<code>static</code>修饰的方法不能被重写</li></ul></li><li><p>注意子类定义和父类(或接口)相同名字的属性时的一些情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10000</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        son.show();</span><br><span class="line">        son.show2();</span><br><span class="line">        <span class="comment">//输出结果为：10000 1 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建子类对象的过程就是从底层的基类开始往上，一层层地调用构造方法</p></li><li><p>在调用子类的构造器的时候，如果没有显示的写出<code>super</code>或<code>this</code>，那么编译器会在子类构造方法开头默认加上<code>super();</code></p></li></ul></li><li><p>多态</p><ul><li>所谓多态，实际上就是一个对象的多种状态(允许程序中出现重名现象)  </li><li>行为的多态、对象的多态</li><li>向上造型(自动)<ul><li>父类的引用可以调用子类的对象</li><li>能调用什么，看引用的类型</li><li>并且调用的是子类重写后的方法，看对象类型，遵循运行期绑定</li></ul></li><li>向下转型(强制)<ul><li>必须先发生向上造型，之后才可以向下转型</li><li><code>instanceof</code>判断为<code>true</code>可进行强制类型转换，否则会抛出<code>ClassCastException</code>异常</li></ul></li><li>多态的表现形式:<ul><li>重写：根据对象来多态</li><li>重载：根据参数来多态</li></ul></li></ul></li></ol><h2 id="十一、注解Annotation"><a href="#十一、注解Annotation" class="headerlink" title="十一、注解Annotation"></a>十一、注解Annotation</h2><ol><li><p>注解概述</p><ul><li>可在类、方法、属性上进行标记</li><li>又称元数据(MetaData)，其实就是代码里的特殊标记</li><li>可以在不改变原有逻辑的情况下，在源文件中嵌入一些补充信息</li><li>有成员变量称为元数据，无成员变量称为标记</li></ul></li><li><p>基本的Annotation</p><ul><li><code>@Override</code> 限定重写父类方法，该注释只能用于方法</li><li><code>@Deprecated</code> 用于表示某个程序元素(类，方法)已过时</li><li><code>@SuppressWarnings</code> 抑制编译器警告</li></ul></li><li><p>自定义注解</p><ul><li><code>@interface</code>关键字(其本身相当于一个接口，可以被实现)</li><li>使用类似于接口方法声明的方式来定义注解的属性:其中返回值称为属性的类型，方法名为属性的名称</li><li>设置默认属性值用<code>default</code>关键字 </li><li><code>value</code>为注解系统内定属性名称，所以为其赋值时可以省略</li><li>可以使用<code>@AliasFor(&quot;属性别名&quot;)</code>注解为注解的属性取别名(Spring中的注解)</li></ul></li><li><p>JDK的元Annotation修饰其他Annotation定义</p><ul><li><code>@Retention</code> 指定Annotation可以保留多长时间 <code>RententionPolicy</code><ul><li><code>SOURCE</code> 只会保留在程序源文件中，编译后不会保存</li><li><code>CLASS</code> 编译后会保存在类文件中，但是不会随类加载到JVM中</li><li><code>RUNTIME</code> 会随类一起加载到JVM中</li></ul></li><li><code>@Target</code> 指定被修饰的注解能用于修饰哪些程序元素 <code>ElementType</code></li><li><code>@Documented</code> 注解可被JavaDoc工具提取成文档</li><li><code>@Inherited</code> 被它修饰的注解具有继承性，被子类自动继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "Hello World!"</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "Du Huang"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>通过反射机制提取Annotation信息</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span>(value = <span class="string">"您好 世界!"</span>, name = <span class="string">"打爆任何人。"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Class&lt;Test&gt; clazz = Test.class;</span><br><span class="line">        <span class="comment">//Annotation[] annotations=MyAnnotation.class.getDeclaredAnnotations();</span></span><br><span class="line">        <span class="comment">//Annotation[] annotations=MyAnnotation.class.getAnnotations();</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(MyAnnotation.class)) &#123;</span><br><span class="line">            <span class="comment">//getDeclaredAnnotation...方法会忽略从父类继承的注解</span></span><br><span class="line">            MyAnnotation myAnnotation = clazz.getAnnotation(MyAnnotation.class);</span><br><span class="line">            System.out.println(myAnnotation.value());</span><br><span class="line">            System.out.println(myAnnotation.name());</span><br><span class="line">            System.out.println(myAnnotation.toString());</span><br><span class="line">            System.out.println(myAnnotation.annotationType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="十二、Object类和包装类"><a href="#十二、Object类和包装类" class="headerlink" title="十二、Object类和包装类"></a>十二、Object类和包装类</h2><ol><li><code>Object</code>类概述<ul><li>唯一没有父类的类</li><li>所有类的父类，没有继承其它类的类默认继承<code>Object</code></li></ul></li><li><code>Object</code>类部分方法<ul><li><code>toString()</code> 获取对象相关信息</li><li><code>equals()</code> 对象比较</li><li><code>clone()</code> 重写该方法的类需要实现<code>Cloneable</code>接口</li><li><code>finalize()</code> 对象被回收时调用(<code>System.gc();</code> 可建议JVM回收垃圾，但是无法控制，因为这是由JVM的算法决定的)</li></ul></li><li>包装类概述<ul><li>为了满足面向对象概念，利用类结构对八大基本数据类型进行包装<table><thead><tr><th align="center">No.</th><th align="center">基本数据类型</th><th align="center">包装类</th><th align="center">父类</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">byte</td><td align="center">Byte</td><td align="center">Number</td></tr><tr><td align="center">2</td><td align="center">short</td><td align="center">Short</td><td align="center">Number</td></tr><tr><td align="center">3</td><td align="center">int</td><td align="center">Integer</td><td align="center">Number</td></tr><tr><td align="center">4</td><td align="center">long</td><td align="center">Long</td><td align="center">Number</td></tr><tr><td align="center">5</td><td align="center">float</td><td align="center">Float</td><td align="center">Number</td></tr><tr><td align="center">6</td><td align="center">double</td><td align="center">Double</td><td align="center">Number</td></tr><tr><td align="center">7</td><td align="center">boolean</td><td align="center">Boolean</td><td align="center">Object</td></tr><tr><td align="center">8</td><td align="center">char</td><td align="center">Character</td><td align="center">Object</td></tr></tbody></table></li></ul></li><li>装箱与拆箱<ul><li>装箱：将基本数据类型保存到包装类中<ul><li>自动装箱<code>Integer iObject=i;</code>(包装类 变量=基本类型)</li><li>手动装箱<code>Integer iObject=Integer.valueOf(i);</code>(包装类 变量=包装类.valueOf(基本类型))</li></ul></li><li>拆箱：从包装类中获取基本数据类型<ul><li>自动拆箱<code>int i=iObject</code>(基本类型 变量=包装类变量)</li><li>手动拆箱<code>int i=iObject.intValue();</code>(基本类型 变量=包装类变量.intValue())</li></ul></li><li>jdk1.5之后提供了自动装箱与自动装箱，jdk1.9开始包装类的构造方法上出现了过期声明</li><li><code>Integer</code> <code>Byte</code> <code>Short</code> <code>Long</code> <code>Character</code> 也有与字符串常量池类似的对象池概念<ul><li>采用自动采用自动(或<code>valueOf()</code>方法)装箱的对象可复用(在一定范围内可复用)</li><li>通过构造方法<code>new</code>对象不可复用</li><li>具体表现在<code>==</code>和<code>equals()</code>比较的结果不同</li></ul></li></ul></li><li>字符串与基本类型的相互转换<ul><li>基本类型转换为字符串<ul><li><code>基本类型+&quot;&quot;</code> 会产生垃圾不推荐</li><li><code>String.valueOf(基本类型)</code> 不会产生垃圾推荐</li></ul></li><li>字符串转换为基本类型<ul><li><code>Number</code>类的子类都提供相应的静态转换方法，例<code>int i=Integer.parseInt(&quot;1&quot;);</code>(如果转换失败抛出<code>NumberFormatException</code>)</li><li><code>Character</code>类不需要此方法，<code>Boolean</code>提供<code>parseBoolean()</code>静态方法</li></ul></li></ul></li></ol><h2 id="十三、抽象类和接口"><a href="#十三、抽象类和接口" class="headerlink" title="十三、抽象类和接口"></a>十三、抽象类和接口</h2><ol><li>抽象方法<ul><li>由<code>abstract</code>修饰的方法</li><li>只有方法的定义，没有具体的实现(连<code>{}</code>都没有)</li><li>抽象方法不允许使用<code>final</code>修饰</li></ul></li><li>抽象类<ul><li>由<code>abstract</code>修饰的类</li><li>包含抽象方法的类必须是抽象类，不包含抽象方法的类也可以声明为抽象类(我乐意)</li><li>抽象类不能被实例化</li><li>抽象类是需要被继承的，子类：<ul><li>重写所有的抽象方法(变不完整为完整)</li><li>也声明为抽象类(一般不这样做)   </li></ul></li><li>抽象类的意义:<ul><li>封装子类共有的属性和行为(代码复用)</li><li>为所有子类提供统一的类型(向上造型)</li><li>可以包含抽象方法，为所有子类提供统一的入口，子类的具体实现不同，但方法的定义是一致的</li></ul></li></ul></li><li>接口<ul><li>是一种由<code>interface</code>定义的特殊的类</li><li>接口中属性只能时常量(默认添加<code>public static final</code>)</li><li>接口中方法只能是公共的，可以是<code>abstract</code>或<code>default</code>或<code>static</code>方法(<code>default</code>方法和<code>static</code>方法出现在jdk1.8以后，可以说是对有缺陷老代码的补救措施)</li><li>接口中没有方法体的方法默认添加<code>public abstract</code>，其它默认添加<code>public</code></li><li>接口中内部类默认加<code>public static</code>(包括内部接口，内部抽象类)</li><li>接口不能被实例化</li><li>接口是需要被实现的，实现类必须重写接口中的所有抽象方法(或者声明为抽象类)</li><li>一个类可以实现多个接口，用逗号分隔(若又继承又实现时，应先继承后实现)</li><li>接口可以继承接口(可以继承好几个接口用逗号分隔)</li><li>如果这几个接口有相同名字的变量，那么它们需要通过“接口名.变量名”的形式来访问</li><li>如果这几个接口有相同名字的方法，如果是<code>default</code>方法则要求子接口必须重写该方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFatherA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFatherB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 子接口继承的两个父接口有同名方法时的情况测试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ISon</span> <span class="keyword">extends</span> <span class="title">IFatherA</span>, <span class="title">IFatherB</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 两个父接口中有同名default方法子接口必须要重写</span></span><br><span class="line"><span class="comment">    * 还可以重写为抽象方法(虽然可能没意义但编译器允许)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">defaultMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 抽象方法不能被重写</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 抽象方法不重写也没错</span></span><br><span class="line"><span class="comment">    * 也可以重写为抽象方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="十四、泛型"><a href="#十四、泛型" class="headerlink" title="十四、泛型"></a>十四、泛型</h2><ol><li><p>泛型的概述</p><ul><li>提高类型的安全并能简化类型转换的过程，在泛型处理过程中，所有的类型转换都是自动和隐式的，泛型将类型的错误提前到了编译期</li><li>泛型是jdk1.5新添加的特性</li><li>泛型就是将类型参数化</li></ul></li><li><p>没有泛型的情况</p><ul><li>可以使用<code>Object</code>类和类型强转来实现类似的功能，但是数据类型转换比较复杂，且在转换中会产生不安全的因素</li></ul></li><li><p>泛型的使用</p><ul><li><code>Ioo&lt;String&gt; a =new Ioo&lt;String&gt;();</code>(jdk1.5)</li><li><code>Ioo&lt;String&gt; a =new Ioo&lt;&gt;();</code>(jdk1.7)</li><li>也可以当没有泛型来使用相当于传入<code>Object</code></li></ul></li><li><p>泛型的基本写法</p><ul><li><p>以尖括号<code>&lt;参数类型&gt;</code>的形式放在类名后面，泛型处理的必须是引用类型，不能用它来处理基本类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类</span></span><br><span class="line">Gen&lt;T&gt;&#123;</span><br><span class="line">    <span class="comment">//属性类型  </span></span><br><span class="line">    T obj;</span><br><span class="line">    <span class="comment">//参数类型</span></span><br><span class="line">    Gen(T obj)&#123;&#125;</span><br><span class="line">    <span class="comment">//返回值类型</span></span><br><span class="line">    <span class="function">T <span class="title">getObj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以使用两个或多个类型参数<code>&lt;T,E&gt;</code>字母随便</p></li></ul></li><li><p>类型边界</p><ul><li><code>&lt;T extends 类&gt;</code>类就为T的上界</li><li><code>&lt;T super 类&gt;</code>类就为T的下界</li></ul></li><li><p>通配符的使用</p><ul><li>解决泛型类型的引用传递问题，例如方法的参数列表有<code>Gen&lt;String&gt; g</code>则方法不能接受<code>Gen&lt;Integer&gt;</code>类型的参数(一个类实现了一个接口，那么该接口可以理解为该类的父类，其为接口子类)</li><li>通过不设置泛型的方式也可以实现接受任意泛型对象的引用，例如方法的参数设置为<code>Gen</code>，但是参数在方法中使用无法利用泛型的安全特性</li><li><code>&lt;?&gt;</code>无边界类型通配符，等同于上边界通配符<code>&lt;? extends Object&gt;</code>，所以可以以Object类去获取数据</li><li><code>&lt;? extends 父类型&gt;</code>上边界类型通配符：因为可以确定父类型，所以可以用父类型去获取数据(向上转型)，但是不能写入数据</li><li><code>&lt;? super 子类型&gt;</code>下边界类型通配符，等同于自身加上边界通配符<code>&lt;? extends Object&gt;</code>，因为可以确定最小类型，所以可以用最小类型去写入数据(向上转型)，也可以以Object类去获取数据 </li></ul></li><li><p>泛型方法</p><ul><li>在非泛型类中也可以有泛型方法</li><li>定义泛型方法的格式 <code>修饰符 方法类型 &lt;参数类型列表&gt; 返回值类型 方法名(参数列表){}</code></li><li>参数类型由方法运行时所传参数类型决定</li></ul></li><li><p>继承泛型类或接口</p><ul><li>父类是泛型类，子类也是泛型类<ul><li>声明中必须包含其父类的类型参数，即便在子类中不使用，仍然要在参数列表中指定它</li><li><code>public class GenChild&lt;T,V,K&gt; extends GenParent&lt;T&gt;{}</code></li><li><code>public class GenChild&lt;T&gt; extends GenParent&lt;T&gt;</code></li></ul></li><li>父类是泛型类，子类不是泛型类<ul><li><code>public class GenChild extends GenParent&lt;具体类&gt;</code></li></ul></li><li>父类不是泛型类，子类是泛型类<ul><li>正常写就可以，没有强制性的要求</li><li><code>public class GenChild&lt;T&gt; extends GenParent</code></li></ul></li><li>继承泛型接口同理</li><li>对于泛型类的继承来说，方法重写同样适用</li></ul></li></ol><h2 id="十五、枚举"><a href="#十五、枚举" class="headerlink" title="十五、枚举"></a>十五、枚举</h2><ol><li>枚举类概述<ul><li>在某些情况下，一个类的对象是有限而且固定的(例如季节类，只能有4个对象)</li><li>jdk1.5开始，java支持了枚举结构的定义(简化多例设计)</li></ul></li><li>手动实现枚举类<ul><li>因为枚举类的对象是有限个，所以不能在类的外部创建类的对象，使用<code>private</code>修饰构造器</li><li>因为对象是固定的，所以属性是常量，属性使用<code>private final</code>修饰</li><li>在类的内部创建对象，但需要在类的外部能够访问到该对象，而且还不能修改，把该类的所有实例都使用<code>public static final</code>来修饰</li></ul></li><li>使用<code>enum</code>定义枚举类<ul><li>使用<code>enum</code>定义的枚举类默认继承了<code>java.lang.Enum</code>类</li><li>枚举类的构造器只能使用private访问控制符</li><li>枚举类的所有实例必须在枚举类中第一行显示列出(<code>,</code>分割<code>;</code>结尾)，列出的实例系统会自动添加<code>public static final</code>修饰 </li><li>jdk1.5中可以在<code>switch</code>表达式中使用枚举类的对象作为表达式，<code>case</code>子句可以直接使用枚举值的名字，无需添加枚举类作为限定</li><li>若枚举只有一个成员，则可以作为一种单例模式的实现方式</li><li>枚举类使用<code>private final</code>修饰的属性应该在构造器中为其赋值，枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</li></ul></li><li>枚举类可以实现接口<ul><li>枚举类可以实现一个或多个接口</li><li>可以对每个枚举类的对象分别实现方法，在列表中用<code>{}</code>实现</li><li>也可以实现一个方法用<code>对象.toString().equals(&quot;枚举名字&quot;)</code>判断执行不同的代码块</li></ul></li><li>枚举类常用方法<ul><li>使用一个字符串获取枚举类对象，可以使用<code>valueof</code>方法</li><li>所有的枚举类都提供了一个<code>values</code>方法，该方法可以很方便地遍历所有的枚举值</li></ul></li></ol><h2 id="十六、包和访问控制权限"><a href="#十六、包和访问控制权限" class="headerlink" title="十六、包和访问控制权限"></a>十六、包和访问控制权限</h2><ol><li>包的概述<ul><li>可以将不同功能的文件进行分割</li><li>在不同的包中可以有重名文件</li><li>完整的类名为包名加类名</li></ul></li><li>包的定义与导入<ul><li>源代码的首行使用<code>package</code>定义包名称</li><li>使用<code>import</code>导入包(可以使用通配符<code>*</code>，对性能没有影响)</li><li>可以使用<code>import static</code>导入静态方法</li><li><code>java.lang</code>基本包中的类不需要<code>import</code></li></ul></li><li>当类没有包时<ul><li>没有包的类(开头没有<code>package</code>的类)等效于在一个没有名字的包中</li><li>其它包中的类是无法调用它们的，但是它们之间可以互相调用(没有包名且在一个目录下)，也可以调用别的包中的类</li></ul></li><li><code>jar</code>文件  <ul><li><code>javac -d . *.java</code>将所有<code>.java</code>文件编译成<code>.class</code>文件并且放在其当前文件夹下</li><li><code>jar -cvf jar包名字.jar 目标</code>将目标文件夹打包成<code>jar</code>包</li><li><code>java -jar jar包.jar</code>运行<code>jar</code>包</li><li>如果想要在java程序中使用别的<code>jar</code>包需要配置环境变量<code>CLASSPATH</code></li></ul></li><li>访问控制权限<ol><li>对于类和接口<ul><li>只有两种权限<code>public</code>和<code>default</code></li><li>声明为<code>public</code>的类必须与所在的<code>.java</code>文件同名，一个<code>.java</code>文件里只能声明一个<code>public</code>的类</li></ul></li><li>对于方法和属性(或内部类)<table><thead><tr><th align="center">No.</th><th align="center">范围</th><th align="center">private</th><th align="center">default</th><th align="center">protected</th><th align="center">public</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">同一个包的同一类</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">2</td><td align="center">同一个包的不同类</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">3</td><td align="center">不同包的子类</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">4</td><td align="center">不同包的非子类</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">√</td></tr></tbody></table></li></ol></li></ol><h2 id="十七、内部类"><a href="#十七、内部类" class="headerlink" title="十七、内部类"></a>十七、内部类</h2><ol><li>内部类概述<ul><li>内部类是指一种嵌套的结构关系</li><li>在一个类的内部可以继续定义一个类结构(普通类、抽象类、接口)</li><li>使得程序的结构定义更加灵活</li><li>类中套类，外面的类称为<code>Outer</code>，里面的类称为<code>Inner</code></li><li>当内部类源代码进行编译后，字节码文件为<code>Outer$Inner.class</code></li><li>内部类最大的作用在于可以与外部类直接进行私有属性的相互访问，避免对象引用所带来的麻烦</li></ul></li><li>成员内部类<ul><li>内部类通常只服务于外部类，内部类对象一般都是在外部类中创建的</li><li>外部类外面也可以创建创建内部类 <code>Outer.Inner in=new Outer().new Inner();</code></li><li>外部类可以直接利用内部类的对象访问内部类私有成员</li><li>内部类中可以直接访问外部类的私有的成员(内部类中有个隐式的引用指向了创建它的外部类对象<code>外部类名.this</code>)</li><li>内部类也可以用<code>abstract</code>修饰，需要被继承使用<ul><li>可以先继承外部类，再在其中定义内部类继承该抽象内部类</li><li>或者在外部类外面直接继承，需要先传入其外部类对象</li></ul></li></ul></li><li>静态内部类<ul><li>在内部类前添加<code>static</code>修饰符</li><li>创建静态内部类的对象，不需要其外部类的对象 <code>Outer.Inner in=new Outer.Inner();</code></li><li>静态内部类中可以声明<code>static</code>成员变量，非静态内部类中不可以</li><li>静态内部类不可以使用外部类的非静态成员变量和方法</li><li>外部类内可以定义内部接口，默认加了<code>static</code>修饰，可在外部类外面直接被实现</li></ul></li><li>局部内部类<ul><li>局部内部类里面可以访问外部类的所有成员变量</li><li>局部内部类里面也可以访问方法中的局部变量</li><li>jdk1.8之前，局部内部类只能访问<code>final</code>修饰的局部变量(变量生命周期问题)</li></ul></li><li>匿名内部类<ul><li>若想创建一个类(子类)的对象，并且对象只需要被创建一次，此时该类不必命名，称为匿名内部类</li><li>匿名内部类可以减少类的定义数量</li><li>jdk1.8之前，匿名内部类中访问外部的变量，该变量必须是<code>final</code>修饰的</li></ul></li><li>内部类的继承 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承普通内部类(非static修饰的)：</span></span><br><span class="line"><span class="comment"> * 1.需要在构造方法中传入其外部类对象</span></span><br><span class="line"><span class="comment"> * 2.需要先调用外部类的构造方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(Outer out)</span></span>&#123;</span><br><span class="line">        out.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="十八、Lambda表达式"><a href="#十八、Lambda表达式" class="headerlink" title="十八、Lambda表达式"></a>十八、Lambda表达式</h2><ol><li><p>Lambda概述</p><ul><li>jdk1.8中引入的重要技术特征</li><li>适用于SAM(Single Abstract Method)，即只含有一个抽象方法的接口的情况</li><li>用于简化匿名内部类的定义</li></ul></li><li><p>Lambda表达式基本语法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1.匿名内部类定义</span></span><br><span class="line">        IMessage iMessage = <span class="keyword">new</span> IMessage() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 2.Lambda表达式定义</span></span><br><span class="line">        iMessage = (str) -&gt; &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 3.要实现的方法体仅有一行，进一步简化</span></span><br><span class="line">        iMessage = (str) -&gt; System.out.println(str);</span><br><span class="line">        <span class="comment">// 4.方法传参只有一个时，进一步简化</span></span><br><span class="line">        iMessage = str -&gt; System.out.println(str);</span><br><span class="line">        <span class="comment">// 5.使用方法引用</span></span><br><span class="line">        iMessage = System.out::println;</span><br><span class="line">        <span class="comment">// 6.如果方法体为单行返回值语句，则可以省略return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 该注解表示此为函数式接口，里面只允许定义一个抽象方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMessage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法引用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法引用与对象引用的概念类似，指的是可以为方法进行别名定义</span></span><br><span class="line">        <span class="comment">//1. 引用静态方法</span></span><br><span class="line">        IFunction1 function1 = String::valueOf;</span><br><span class="line">        <span class="comment">//2. 引用某个对象的普通方法(无传参)</span></span><br><span class="line">        IFunction2 function2 = <span class="string">""</span>::toUpperCase;</span><br><span class="line">        <span class="comment">//3. 引用某个对象的普通方法(有传参,对象本身作为第一个参数)</span></span><br><span class="line">        IFunction3 function3 = String::toUpperCase;</span><br><span class="line">        IFunction4 function4 = String::compareTo;</span><br><span class="line">        <span class="comment">//4. 引用构造方法</span></span><br><span class="line">        IFunction5 function5 = String::<span class="keyword">new</span>;</span><br><span class="line">        <span class="comment">//5. 为了简化开发，jdk1.8开始提供了一个新的开发包java.util.function</span></span><br><span class="line">        <span class="comment">//此包中提供许多内置的函数式接口 Function Consumer Supplier Predicate</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction1</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction2</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">toUpperCase</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction3</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">toUpperCase</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String s1, String s2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IFunction5</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">creat</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="十九、异常的捕获与处理"><a href="#十九、异常的捕获与处理" class="headerlink" title="十九、异常的捕获与处理"></a>十九、异常的捕获与处理</h2><ol><li>异常概述<ul><li>异常是指程序运行过程中由于程序处理逻辑上的错误而导致程序中断的一种指令流</li><li>产生异常时，如果程序中没有提供异常处理的支持，JVM采用默认异常处理方式，首先打印异常信息，然后直接退出当前的程序</li><li>异常出现的原因：<ul><li>用户输入错误</li><li>代码的错误</li><li>环境的因素</li></ul></li><li>异常机制保证了程序的健壮性</li></ul></li><li>异常处理<ul><li><code>try</code> 把可能发生异常的代码包起来，当发生异常时，将异常抛出</li><li><code>catch</code> 捕获异常并处理</li><li><code>finally</code> 不管是否发生异常，都会执行</li><li><code>try</code> <code>catch</code> <code>finally</code> 是可以嵌套使用的</li><li>程序发生异常的时候，程序就直接从<code>try</code>语句块执行到<code>catch</code>语句块，不再继续执行<code>try</code>语句块中该语句后的语句</li><li><code>try</code> 不能单独出现，后面必须跟着<code>catch</code>或<code>finally</code>或两者都有</li><li><code>return;</code> 不会影响<code>finally</code>语句块的执行，<code>System.exit(0);</code>可以</li><li><code>throw</code> 手动抛出一个异常</li><li><code>throws</code> 将方法的产生异常交给调用者处理</li></ul></li><li>异常的分类<ul><li><code>Throwable</code><ul><li><code>Error</code><ul><li>它是java运行时的内部错误以及资源耗尽错误，很难恢复，不需要用户来处理</li><li><code>IOError</code> <code>VirtualMachineError</code> <code>StackOverflowError</code> <code>OutOfMemoryError</code></li></ul></li><li><code>Exception</code><ul><li><code>RuntimeException</code><ul><li>运行时异常，编译器不会检测该异常，</li><li><code>NullPointerException</code> <code>ClassCastException</code> <code>ArithmeticException</code> <code>IndexOutOfBoundsException</code> <code>NumberFormatException</code></li></ul></li><li>非<code>RuntimeException</code><ul><li>不显式处理编译不通过，由环境因素导致 </li><li><code>ClassNotFoundException</code> <code>CloneNotSupportedException</code> <code>IOException</code></li></ul></li></ul></li></ul></li></ul></li><li>自定义异常<ul><li>自定义异常创建<ul><li>继承Throwable(不推荐)</li><li>继承Exception(不用显示处理则继承<code>RuntimeException</code>)</li></ul></li><li>自定义异常使用：自己定义的异常一般来说是用于<code>throw</code></li><li>两个或者多个不同的异常出现在同一个程序中，并且会发生嵌套抛出，我们称之为异常链   </li><li><code>exception1.initCause(exception2);</code> 异常1是由异常2造成的</li></ul></li><li><code>assert</code>关键字<ul><li>jdk1.4后引入的，主要功能是进行断言</li><li>默认情况下是不开启断言的，启用断言需要启动时增加<code>-ea</code>选项</li><li>断言结果为<code>false</code>程序会抛出<code>java.lang.AssertionError</code></li></ul></li><li><code>try-with-resource</code>机制<ul><li>传统的手动释放外部资源一般放在一般放在<code>try{}catch(){}finally{}</code>机制的<code>finally</code>代码块中，非常繁琐</li><li>jdk1.7之后有了<code>try-with-resource</code>处理机制</li><li>首先被自动关闭的资源需要实现<code>Closeable</code>或者<code>AutoCloseable</code>接口，因为只有实现了这两个接口才可以自动调用<code>close()</code>方法去自动关闭资源</li><li>写法为<code>try(){}catch(){}</code>，将要关闭的外部资源在<code>try()</code>中创建，<code>catch()</code>捕获处理异常</li><li>扩展链接：<ul><li><a href="https://blog.csdn.net/weixin_42447959/article/details/81192098" title="利用try-with-resource机制关闭连接" target="_blank" rel="noopener">利用try-with-resource机制关闭连接</a>    </li><li><a href="https://blog.csdn.net/wtopps/article/details/71108342" title="使用Try-with-resources自动关闭资源" target="_blank" rel="noopener">使用Try-with-resources自动关闭资源</a></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;九、类的基础&quot;&gt;&lt;a href=&quot;#九、类的基础&quot; class=&quot;headerlink&quot; title=&quot;九、类的基础&quot;&gt;&lt;/a&gt;九、类的基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;类的概述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类就是事物的集合和抽象，它所代表的是这类事物所共有的一
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="面向对象" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="面向对象" scheme="https://huangdu.work/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="泛型" scheme="https://huangdu.work/tags/%E6%B3%9B%E5%9E%8B/"/>
    
      <category term="内部类" scheme="https://huangdu.work/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
      <category term="Lambda表达式" scheme="https://huangdu.work/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="异常处理" scheme="https://huangdu.work/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    
      <category term="枚举" scheme="https://huangdu.work/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="注解" scheme="https://huangdu.work/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>linux笔记之shell脚本篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/OS/linux/shell%E8%84%9A%E6%9C%AC/linux%E7%AC%94%E8%AE%B0%E4%B9%8Bshell%E8%84%9A%E6%9C%AC%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/OS/linux/shell脚本/linux笔记之shell脚本篇/</id>
    <published>2019-10-21T16:00:00.000Z</published>
    <updated>2019-10-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、shell概述"><a href="#一、shell概述" class="headerlink" title="一、shell概述"></a>一、shell概述</h2><ol><li>shell是系统跟计算机硬件交互时使用的中间介质，它是系统的一个工具</li><li>bash(Bourne Again Shell)是sh(Bourne Shell)的增强版本</li></ol><h2 id="二、bash特点"><a href="#二、bash特点" class="headerlink" title="二、bash特点"></a>二、bash特点</h2><ol><li>记录命令历史<ul><li>linux预设可以记录1000条我们敲过的命令，这些命令保存在用户的家目录中的<code>.bash_history</code>文件中</li><li><code>!!</code> 执行上一条指令          </li><li><code>!n</code> 执行上n条命令(n为负整数)</li><li><code>!字符串</code> 执行命令历史中最近一次以字符串开头的指令(字符串长度大于等于1)</li></ul></li><li>指令和文件名补全<ul><li><code>tab</code>键可以补全一个指令，也可以补全一个路径或者一个文件名</li><li><code>tab</code>键连续按两次，系统则会把所有的指令或者文件名列出来</li></ul></li><li>别名<ul><li><code>alias</code> 把一个常用的并且很长的指令别名一个简洁易记的指令</li><li><code>unalias</code> 解除别名</li></ul></li><li>通配符<ul><li><code>*</code> 用来匹配零个或多个字符</li><li><code>?</code> 用来匹配一个字符</li></ul></li><li>输入输出重定向<ul><li><code>&lt;</code> 输入重定向</li><li><code>&gt;</code> 输出重定向</li><li><code>2&gt;</code> 错误重定向</li><li><code>&gt;&gt;</code> 追加重定向</li></ul></li><li>管道符<ul><li><code>|</code> 把前面的命令运行的结果丢给后面的命令</li></ul></li><li>作业控制<ul><li><code>Ctrl+Z</code> 暂停当前进程</li><li><code>Ctrl+C</code> 终止当前进程</li><li><code>fg</code> 恢复当前进程</li><li><code>bg</code> 后台运行</li><li><code>jobs</code> 查看当前shell后台执行的任务</li></ul></li></ol><h2 id="三、变量及常用配置"><a href="#三、变量及常用配置" class="headerlink" title="三、变量及常用配置"></a>三、变量及常用配置</h2><ol><li><code>/etc/profile</code> 想系统内所有用户登录后都能使用该变量</li><li>用户主目录下的<code>.bashrc</code>文件 只想让当前用户使用该变量<ul><li>文件末行加入 <code>export myname=Aming</code></li><li><code>a=b</code> 等号两边不能有空格</li><li>变量名只能由英、数字以及下划线组成，而且不能以数字开头</li><li>当变量内容带有特殊字符时，需要加上单引号，内容中带有单引号用双引号</li><li>如果变量内容需要用到其他命令运行结果可以使用反引号</li><li>变量内容累加到其他变量需要加双引号</li></ul></li><li><code>env</code> 显示系统环境变量(<code>$PATH</code> <code>$HOME</code> <code>$LOGNNAME</code>)</li><li><code>set</code> 系统预设的全部变量都显示出来</li><li><code>export [变量名]</code> 让shell的子shell也知道变量的值,不加变量名则声明所有变量</li><li><code>unset 变量名</code> 取消某个变量</li><li><code>/etc/bashrc</code> <code>$umask</code> <code>$PS1</code> 就是我们敲命令时前面的那串字符串</li><li>每个用户的主目录下有几个隐藏文件<ul><li><code>.bash_profile</code> 定义了用户的个人化路径与环境变量的文件名称</li><li><code>.bashrc</code> 该文件包含专用于你的shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取</li><li><code>.bash_history</code> 记录命令历史</li><li><code>.bash_logout</code> 当退出shell时，会执行该文件，可以把一些清理的工作放到这个文件中。</li></ul></li><li><code>source</code> 目前设定的配置刷新</li></ol><h2 id="四、linux-shell中的特殊符号"><a href="#四、linux-shell中的特殊符号" class="headerlink" title="四、linux shell中的特殊符号"></a>四、linux shell中的特殊符号</h2><ol><li><code>*</code> 零个或多个字符或数字</li><li><code>?</code> 一个任意的字符</li><li><code>#</code> 注释，后面的内容linux忽略掉</li><li><code>\</code> 转义字符，后面的特殊符号转义成普通字符</li><li><code>|</code> 管道符，符号前面的命令结果丢给符号后面的命令</li><li><code>$</code> 变量前面的标识符，<code>!$</code> 表示上条命令中最后出现的那个东西</li><li><code>;</code> 一行中运行多条命令</li><li><code>~</code> 用户的家目录</li><li><code>&amp;</code> 如果想把一条命令放到后台执行的话，需要加上这个符号，通常用于命令运行时间非常长的情况</li><li><code>&gt;</code> <code>&gt;&gt;</code> <code>2&gt;</code> <code>2&gt;&gt;</code> 重定向 追加 错误重定向 错误追加</li><li><code>[]</code> 其中字符中任一个(同正则表达式)</li><li><code>&amp;&amp;</code> <code>||</code> 执行成功为true，执行失败为false，遵循短路</li></ol><h2 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h2><ol><li><code>bash</code> 打开一个shell，<code>exit</code> 退出当前shell</li><li><code>pstree</code> 将系统所有进程通过树形结构打印出来</li><li><code>grep</code> 过滤一个或多个字符 </li><li><code>cut</code> 截取某一个字段 <code>-d &quot;分隔字符&quot;</code>，<code>[-cf]n</code> 第几个，第几段</li><li><code>sort</code> 用作排序</li><li><code>wc</code> 统计文档的行数、字符数、词数 <code>-l</code> <code>-m</code> <code>-w</code></li><li><code>uniq</code> 去重复的行，需要先排序</li><li><code>tee</code> 包含<code>&gt;</code>的功能，同时显示到屏幕上</li><li><code>tr</code> 替换字符</li><li><code>split -b 500 /etc/passwd passwd</code> 切割文档</li></ol><h2 id="六、正则表达式-Regular-Expression"><a href="#六、正则表达式-Regular-Expression" class="headerlink" title="六、正则表达式(Regular Expression)"></a>六、正则表达式(Regular Expression)</h2><ol><li>它是指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串</li><li><code>[1-9]</code> <code>[123]</code> <code>[^123]</code></li><li><code>^</code> 开头，<code>$</code> 结尾</li><li><code>.</code> 表示任意一个字符</li><li><code>*</code> 零个或多个前面的字符</li><li><code>\{n1,n2\}</code> n1-n2个，n2省略表示大于等于n1个</li><li>支持正则表达式的命令:  <code>grep</code>/<code>egrep</code> <code>sed</code> <code>awk</code></li></ol><h3 id="grep-cinvABC-‘regex’-filename"><a href="#grep-cinvABC-‘regex’-filename" class="headerlink" title="grep [-cinvABC] ‘regex’ filename"></a>grep [-cinvABC] ‘regex’ filename</h3><ul><li><code>-c</code> 打印符合要求的行数</li><li><code>-i</code> 忽略大小写</li><li><code>-n</code> 在输出符合要求的行的同时连同行号一起输出</li><li><code>-v</code> 打印不符合要求的行</li><li><code>-A</code> 后跟一个数字（有无空格都可以），例如-A2则表示打印符合要求的行以及下面两行</li><li><code>-B</code> 打印符合要求的行以及上面n行</li><li><code>-C</code> 打印符合要求的行以及上下各n行</li></ul><h3 id="egrep-grep扩展版"><a href="#egrep-grep扩展版" class="headerlink" title="egrep(grep扩展版)"></a>egrep(grep扩展版)</h3><ul><li><code>?</code> 零个或一个前面的字符</li><li><code>+</code> 一个或一个以上前面的字符</li><li><code>|</code> 或者</li><li><code>()</code> 表示一个整体</li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul><li><code>sed -n &#39;n&#39;p filename</code> 打印某行</li><li><code>sed -n &#39;1,$&#39;p filename</code> 打印多行</li><li><code>sed -n &#39;/regex/&#39;p filename</code> 打印匹配正则的行</li><li><code>sed -e &#39;&#39;p -e &#39;&#39;p -n filename</code> 实现多个行为</li><li><code>sed &#39;n&#39;d filename</code> 删除某行 </li><li><code>sed &#39;1,$&#39;d filename</code> 删除多行</li><li><code>sed &#39;n1,n2s/regex/替换后内容/g&#39; filename</code> 替换n1,n2行中内容，g表示全局，不加g只匹配第一个</li><li><code>sed &#39;s/regex/替换后内容/g&#39; filename</code> 替换全文内容</li><li>除了可以使用<code>/</code>以外<code>#</code>和<code>@</code>也可以</li><li><code>sed &#39;s/\(word1\)\(.*\)\(word2\)/\3\2\1/&#39; filename</code> 替换两个字符串的位置</li><li><code>sed -i &#39;s/regex/替换后内容/g&#39; filename</code> 直接修改文件内容</li></ul><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><ul><li><code>awk -F&#39;:&#39; &#39;{print $1}&#39; filename</code></li><li><code>-F</code> 的作用是指定分隔符，如果不加<code>-F</code>指定，则以空格或者tab为分隔符</li><li><code>print</code> 打印，<code>$1</code>第一字段，<code>$2</code>第二字段，<code>$0</code>表示整行</li><li><code>awk -F&#39;:&#39; &#39;{print $1&quot;@&quot;$2&quot;@&quot;$3}&#39;</code></li><li><code>awk &#39;/regex/&#39; filename</code> 匹配字符或字符串</li><li><code>awk -F&#39;分隔符&#39; &#39;$1~/regex/&#39; filename</code> 某个段去匹配~表示匹配</li><li><code>awk &#39;/regex1/{print $1}/regex2/{print $1}&#39; filename</code> 多次匹配</li><li><code>awk -F&#39;:&#39; &#39;$3==&quot;0&quot;&#39; filename</code> 还有<code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> <code>!=</code> 但是为字符串的比较<code>&amp;&amp;</code> <code>||</code>也有</li><li><code>awk的内置变量</code><ul><li><code>NF</code> 用分隔符后一共有多少段</li><li><code>NR</code> 行数</li><li><code>=</code> 赋值，<code>END</code> 所有行都执行完</li><li><code>awk -F&#39;:&#39; &#39;{(tot+=$3)};END {print tot}&#39; filename</code></li><li><code>awk -F&#39;:&#39; &#39;{if ($1==&quot;root&quot;) print $0}&#39; filename</code></li></ul></li></ul><h2 id="七、shell脚本"><a href="#七、shell脚本" class="headerlink" title="七、shell脚本"></a>七、shell脚本</h2><ol><li><p>shell脚本的基本结构以及如何执行</p><ul><li>shell脚本通常是以<code>.sh</code>为后缀名的</li><li>第一行一定是<code>#！/bin/bash</code> 如果不设置该行，脚本不能被执行</li><li>使用<code>sh</code>来执行脚本，<code>-x</code> 选项来查看这个脚本的执行过程</li><li><code>chmod +x file.sh ./file.sh</code> 加可执行权限后也可直接执行</li><li><code>date</code> 打印当前系统时间</li></ul></li><li><p>shell脚本中的变量</p><ul><li>定义变量<code>变量名=变量值</code> 变量值为一个命令得到用反引号</li><li>引用变量<code>$变量名</code></li><li>数学计算<code>$[$a+$b]</code></li><li><code>read</code>可以从标准输入获得变量的值，后跟变量名，<code>-p</code>选项，输入提示语</li><li>预设变量<ul><li><code>$0</code> 脚本本身名字 </li><li><code>$1</code> 脚本执行时的第一个变量</li><li><code>$2</code> 脚本执行时的第二个变量</li></ul></li></ul></li><li><p>shell脚本中的逻辑判断</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if ((判断语句)) ; then</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((判断语句)) ; then</span><br><span class="line">    command1</span><br><span class="line">else</span><br><span class="line">    command2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ((判断语句))||((判断语句)) ; then</span><br><span class="line">    command1</span><br><span class="line">elif ((判断语句))&amp;&amp;((判断语句)) ; then</span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    command3</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li><li><p>判断语句可使用<code>[]</code>，但要使用<code>-lt</code> <code>-gt</code> <code>-le</code> <code>-ge</code> <code>-eq</code> <code>-ne</code></p></li><li><p><code>if [-e filename] ; then</code></p><ul><li><code>-e</code> 判断文件或目录是否存在</li><li><code>-d</code> 判断是不是目录，并是否存在</li><li><code>-f</code> 判断是否是普通文件，并是否存在</li><li><code>-r</code> <code>-w</code> <code>-x</code> 判断文档是否有相应权限 </li></ul></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">value1)</span><br><span class="line">    command1</span><br><span class="line">    ;;</span><br><span class="line">value2)</span><br><span class="line">    command2</span><br><span class="line">    ;;</span><br><span class="line">value3)</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command4</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure></li></ul></li><li><p>shell脚本中的循环</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 循环的条件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> `seq 1 5`，1-5的一个序列</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以写 1 2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还可以是 `ls` `cat test.txt`</span></span><br><span class="line">for 变量名 in 循环的条件; do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while [判断语句] ; do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 死循环</span></span><br><span class="line">while :; do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure></li></ul></li><li><p>shell脚本中的函数</p><ul><li><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一定要写在调用函数前</span></span><br><span class="line">function 函数名()&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、shell概述&quot;&gt;&lt;a href=&quot;#一、shell概述&quot; class=&quot;headerlink&quot; title=&quot;一、shell概述&quot;&gt;&lt;/a&gt;一、shell概述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;shell是系统跟计算机硬件交互时使用的中间介质，它是系统的一个工具&lt;/
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="OS" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/OS/"/>
    
      <category term="linux" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/OS/linux/"/>
    
      <category term="shell脚本" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/OS/linux/shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="OS" scheme="https://huangdu.work/tags/OS/"/>
    
      <category term="operating system" scheme="https://huangdu.work/tags/operating-system/"/>
    
      <category term="linux" scheme="https://huangdu.work/tags/linux/"/>
    
      <category term="shell脚本" scheme="https://huangdu.work/tags/shell%E8%84%9A%E6%9C%AC/"/>
    
  </entry>
  
  <entry>
    <title>java笔记之基础语法篇</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/java/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/1-java%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%AF%87/"/>
    <id>https://huangdu.work/笔记/java/基础语法/1-java笔记之基础语法篇/</id>
    <published>2019-10-19T16:00:00.000Z</published>
    <updated>2019-10-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、java的基本元素"><a href="#一、java的基本元素" class="headerlink" title="一、java的基本元素"></a>一、java的基本元素</h2><ol><li>空白分隔符<ul><li>空格</li><li>Tab键</li><li>换行符</li></ul></li><li>关键字<br>(不能用于变量名、类名、方法名等)<ul><li>访问控制：<br><code>private</code> <code>protected</code> <code>public</code></li><li>类、方法、变量修饰符：<br><code>abstract</code> <code>class</code> <code>extends</code> <code>final</code> <code>implements</code> <code>interface</code> <code>native</code> <code>new</code> <code>static</code> <code>strictfp</code> <code>synchronized</code> <code>transient</code> <code>volatile</code> <code>enum</code> <code>void</code> <code>var</code></li><li>程序控制：<br><code>break</code> <code>continue</code> <code>return</code> <code>do</code> <code>while</code> <code>if</code> <code>else</code> <code>for</code> <code>instanceof</code> <code>switch</code> <code>case</code> <code>default</code></li><li>异常处理：<br><code>try</code> <code>catch</code> <code>throw</code> <code>throws</code> <code>finally</code> <code>assert</code></li><li>包相关：<br><code>import</code> <code>package</code></li><li>基本类型：<br><code>byte</code> <code>short</code> <code>char</code> <code>int</code> <code>long</code> <code>float</code> <code>double</code> <code>boolean</code> (单独的标识类型：<code>null</code> <code>ture</code> <code>false</code>)</li><li>变量引用：<br><code>super</code> <code>this</code></li><li>保留字：<br><code>goto</code> <code>const</code></li></ul></li><li>标识符<ul><li>标识符是类、方法、变量的名字</li><li>命名规则：<ul><li>可以包含数字、字母、下划线<code>_</code>、美元符号<code>$</code>，但是不能以数字作为开头</li><li>区分大小写</li><li>关键字是不能用作标识符的</li><li>可以使用中文，但不建议使用</li></ul></li></ul></li><li>注释<ul><li>单行注释：<code>//</code></li><li>多行注释：<code>/* */</code></li><li>文档注释：<code>/** */</code> (把关于程序的信息嵌入到程序内部，用javadoc工具来提取这些信息，形成帮助文档)</li></ul></li><li>分隔符<ul><li>除了注释和变量名可以出现中文之外(不建议中文变量名)，其它的地方一律是英文，各种标点符号也必须是英文状态下的</li><li><code>()</code> <strong>圆括号</strong>   <ul><li>定义方法的参数表</li><li>条件语句、循环语句中的条件定义</li><li>定义表达式的优先级</li></ul></li><li><code>{}</code> <strong>花括号</strong>   <ul><li>初始化数组</li><li>定义程序块、类、方法</li></ul></li><li><code>[]</code> <strong>方括号</strong>   <ul><li>声明数组类型</li></ul></li><li><code>;</code> <strong>分号</strong>  <ul><li>表示一个语句的结束</li></ul></li><li><code>,</code> <strong>逗号</strong>  <ul><li>变量声明时用于分隔多个变量</li></ul></li><li><code>.</code> <strong>点号</strong>  <ul><li>用于软件包和子包分隔</li><li>用于类、对象和变量、方法分隔</li></ul></li></ul></li></ol><h2 id="二、八大基本数据类型及数据类型转换"><a href="#二、八大基本数据类型及数据类型转换" class="headerlink" title="二、八大基本数据类型及数据类型转换"></a>二、八大基本数据类型及数据类型转换</h2><ol><li>基本数据类型<ul><li>整型<ul><li><code>byte</code>    1字节 -128~127</li><li><code>short</code>   2字节 -32768~32767</li><li><code>int</code>     4字节 正负21亿多(用的最多)</li><li><code>long</code>    8字节 特别大，当int不够用的时候，才会用long</li></ul></li><li>字符型<ul><li><code>char</code>    2字节 采用Unicode编码格式，支持中文</li></ul></li><li>浮点型<ul><li><code>float</code>   4字节 单精度</li><li><code>double</code>  8字节 双精度(用的最多)</li></ul></li><li>布尔型<ul><li><code>boolean</code> 1字节 <code>true</code>真 <code>false</code>假</li></ul></li></ul></li><li>自动转换<ul><li><code>byte</code> <code>short</code> <code>char</code> <strong>&gt;</strong> <code>int</code> <strong>&gt;</strong> <code>long</code> <strong>&gt;</strong> <code>float</code> <strong>&gt;</strong> <code>double</code> </li><li>目的类型比原来的类型要大</li><li>两种类型是相互兼容的</li><li><code>byte</code> <code>short</code> <code>char</code> 计算时会自动转换为<code>int</code>类型</li><li>对于<code>byte</code> <code>short</code> <code>char</code>类型赋值，只要常量不超过它们的范围可直接赋值</li></ul></li><li>强制类型转换<ul><li>(目标数据类型)目标</li><li>浮点型转整型：把小数位截掉，保留整数位</li><li>长整型赋给短整型：去位</li><li>需要注意数据溢出</li></ul></li></ol><h2 id="三、变量和常量"><a href="#三、变量和常量" class="headerlink" title="三、变量和常量"></a>三、变量和常量</h2><ol><li>java的变量  <ul><li>值可以改变的量</li><li>命名规则：<ul><li>遵循标识符命名规则</li><li>尽量使用有意义的单词</li><li>一般首字母小写</li><li>英文的见名知意、驼峰命名法</li></ul></li></ul></li><li>java的常量  <ul><li>值不能改变的量</li><li>各类型直接常量不能超过它们的范围，否则编译报错</li><li>定义常量  <ul><li>使用final关键字</li><li>习惯上常量都使用大写</li></ul></li><li>整型直接常量<ul><li>默认<code>int</code>类型</li><li>前缀<code>0X</code> <code>0x</code>表示十六进制、<code>0</code>表示八进制、<code>0B</code> <code>0b</code>表示二进制</li><li>后缀<code>L</code> <code>l</code>表示<code>long</code>类型</li></ul></li><li>浮点型直接常量<ul><li>默认<code>double</code>类型</li><li>指数计数法<code>1.39E-43</code> <code>1.39e-43</code>表示<code>1.39×10^-43</code></li><li>后缀<code>D</code> <code>d</code>表示<code>double</code>类型，<code>F</code> <code>f</code>表示<code>float</code>类型</li></ul></li><li>字符型直接常量<ul><li>直接形式：<code>&#39;A&#39;</code>(对于特殊字符需要转义，换行符<code>&#39;\n&#39;</code>)</li><li>八进制形式：<code>&#39;\101&#39;</code></li><li>十进制形式：<code>65</code>(<code>&#39;A&#39;</code>对应<code>65</code>，<code>&#39;a&#39;</code>对应<code>97</code>,<code>&#39;0&#39;</code>对应<code>48</code>)</li><li>十六进制形式：<code>&#39;\u0041&#39;</code></li></ul></li><li>布尔型直接常量<ul><li><code>true</code>真 <code>false</code>假</li></ul></li></ul></li></ol><h2 id="四、赋值与初始化"><a href="#四、赋值与初始化" class="headerlink" title="四、赋值与初始化"></a>四、赋值与初始化</h2><ol><li>赋值<ul><li>是给变量指定一个值或者是改变一个变量的值</li><li><code>int a = 100;</code>初始化 <code>a = 200;</code>赋值</li></ul></li><li>初始化<ul><li>局部变量：<ul><li>在使用之前必须进行初始化(JDK1.4之前必须在声明时初始化)</li></ul></li><li>实例变量和静态变量(类变量)：<ul><li>编译器可以自动对它们进行初始化(<code>final</code>修饰的类变量必须初始化)</li><li><code>byte</code> <code>short</code> <code>char</code> <code>int</code> <code>long</code> &gt; <code>0</code></li><li><code>float</code> <code>double</code> &gt; <code>0.0</code></li><li><code>boolean</code> &gt; <code>false</code></li><li>引用数据类型 &gt; <code>null</code></li></ul></li></ul></li></ol><h2 id="五、字符串"><a href="#五、字符串" class="headerlink" title="五、字符串"></a>五、字符串</h2><ol><li><p>字符串类对象实例化</p><ul><li>直接赋值实例化 <code>String str = &quot;Hello World.&quot;;</code></li><li>构造方法实例化 <code>String str = new String(&quot;Hello World.&quot;);</code></li><li>直接赋值实例化可重用相同的实例，构造方法实例化会开辟新的堆内存空间</li></ul></li><li><p>字符串比较</p><ul><li><code>equals</code>比较内容是否相等</li><li><code>==</code>比较引用地址是否相等</li></ul></li><li><p>字符串连接</p><ul><li>可以用<code>+</code>来连接两个字符串(<code>+</code>在这里是一个连接运算符)</li><li>字符串常量的内容不会改变，采用<code>+</code>连接符会生成新的字符串常量对象</li><li>转义字符：每个转义字符都是由两个符号组成，但是编译器把他当成一个字符<ul><li><code>\n</code> 换行符 光标移动到下一行</li><li><code>\r</code> 回车符 把光标移动到本行的开始处</li><li><code>\t</code> 制表符</li><li>(<code>\r\n</code> windows <code>\n</code> linux <code>\r</code> mac 表示换行)</li></ul></li></ul></li><li><p>字符串常量池</p><ul><li><p>直接赋值实例化的<code>String</code>对象保存在常量池中，供下次重用</p></li><li><p>构造方法实例化的<code>String</code>对象也可调用<code>intern()</code>手动入池</p></li><li><p>静态常量池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//静态常量池</span></span><br><span class="line">        <span class="comment">//程序加载的时候会自动将程序中保存的字符串、普通的常量、类和方法等信息全部分配</span></span><br><span class="line">        String strA = <span class="string">"www.iflytek.com"</span>;</span><br><span class="line">        String strB = <span class="string">"www."</span> + <span class="string">"iflytek"</span> + <span class="string">".com"</span>;</span><br><span class="line">        <span class="comment">//判断结果: true</span></span><br><span class="line">        System.out.println(strA == strB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行时常量池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//运行时常量池</span></span><br><span class="line">        <span class="comment">//程序执行中动态的实例化字符串对象</span></span><br><span class="line">        String logo = <span class="string">"iflytek"</span>;</span><br><span class="line">        String strA = <span class="string">"www.iflytek.com"</span>;</span><br><span class="line">        <span class="comment">//频繁进行这样的操作会产生大量垃圾</span></span><br><span class="line">        String strB = <span class="string">"www."</span> + logo + <span class="string">".com"</span>;</span><br><span class="line">        <span class="comment">//判断结果: false</span></span><br><span class="line">        System.out.println(strA == strB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>字符串其他常用操作：查阅API</p></li></ol><h2 id="六、运算符"><a href="#六、运算符" class="headerlink" title="六、运算符"></a>六、运算符</h2><ol><li>算数运算符<ul><li><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code></li><li>取模运算不建议用于浮点型，结果可能不准确</li><li>对于精度高的运算，需要使用BigDecimal类型</li></ul></li><li>算术赋值运算符<ul><li><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></li><li>计算结果会进行数据类型的自动转换</li></ul></li><li>自增自减运算符<ul><li><code>++</code> <code>--</code></li><li><code>++i</code>先自增再运算 <code>i++</code>先运算再自增</li><li><code>--i</code>先自减再运算 <code>i--</code>先运算再自减</li></ul></li><li>关系运算符<ul><li><code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> <code>==</code> <code>!=</code></li><li>返回值是<code>boolean</code>类型，一般用于判断语句中</li></ul></li><li>逻辑运算符<ul><li><code>&amp;</code>逻辑与 <code>|</code>逻辑或 <code>!</code>逻辑非</li><li><code>&amp;&amp;</code>短路与 <code>||</code>短路或</li></ul></li><li>位运算符<ul><li>实现对两个二进制数的位进行运算</li><li><code>&amp;</code>与 <code>|</code>或 <code>~</code>取反 <code>^</code>异或</li><li><code>&lt;&lt;</code>左移位 <code>&gt;&gt;</code>有符号右移位 <code>&gt;&gt;&gt;</code>无符号右移位</li></ul></li><li>三目运算符<ul><li><code>condition?statement1:statement2</code></li><li>该运算符的返回值类型为statement1和statement2中最大的类型</li></ul></li><li>运算符优先级<ul><li>算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 三目运算符 &gt; 赋值运算符</li><li><code>()</code>括号内优先级最高</li></ul></li></ol><h2 id="七、流程控制"><a href="#七、流程控制" class="headerlink" title="七、流程控制"></a>七、流程控制</h2><ol><li><p>程序的三种结构</p><ul><li>顺序结构</li><li>选择结构(分支结构)</li><li>循环结构</li></ul></li><li><p>选择结构</p><ul><li><p><code>if</code>分支结构</p><ul><li><p><code>if</code>语句结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>if else</code>语句结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition1)&#123;</span><br><span class="line">    statement1;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</span><br><span class="line">    statement2</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    statement3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>switch</code>开关语句</p><ul><li><p><code>switch</code>语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(variable)&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        statement1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        statement2;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        statement3;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>所支持的<code>variable</code>类型<code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>char</code> <code>Character</code> <code>int</code> <code>Integer</code> <code>String</code> <code>enum</code></p></li><li><p>重点要理解有<code>break</code>和没有<code>break</code>的区别</p></li></ul></li></ul></li><li><p>循环结构</p><ul><li><p><code>while</code>循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition)&#123;</span><br><span class="line">    loop body;</span><br><span class="line">    updata condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>do while</code>循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    loop body;</span><br><span class="line">    updata condition;</span><br><span class="line">&#125;<span class="keyword">while</span>(condition);</span><br></pre></td></tr></table></figure></li><li><p><code>for</code>循环结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialize;condition;updata condition)&#123;</span><br><span class="line">    loop body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>foreach</code>结构(加强<code>for</code>循环)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(dataType variable:array|collection)&#123;</span><br><span class="line">    loop body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>死循环<code>for(;;){}</code>比<code>while(true){}</code>效率高</p></li><li><p>循环结构可以在内部嵌入若干个子循环结构</p></li><li><p>循环控制语句</p><ul><li><p><code>break</code>语句 跳出当前循环</p></li><li><p><code>continue</code>语句 停止本次循环，继续执行剩下的循环</p></li><li><p><code>break</code> <code>continue</code>可与label配合跳出多层循环(每个代码块都可以用一个label)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outloop:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;i)&#123;</span><br><span class="line">            <span class="keyword">break</span> outloop;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>return</code>语句 从当前的方法中退出(非循环控制语句)</p></li></ul></li></ul></li></ol><h2 id="八、数组"><a href="#八、数组" class="headerlink" title="八、数组"></a>八、数组</h2><ol><li><p>数组概述</p><ul><li>数组就是一组数的集合，集合中的数据必须是相同类型的，并且每一个数组都有一个名字，也就是数组名，我们可以通过数组名来访问数组中的元素</li></ul></li><li><p>创建数组</p><ul><li><code>ArrayType arrayName[]=new ArrayType[length];</code></li><li><code>ArrayType[] arrayName=new ArrayType[length];//推荐写法</code></li></ul></li><li><p>初始化方式</p><ul><li><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];<span class="comment">//同实例变量和静态变量(类变量)初始化</span></span><br><span class="line">array[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">array[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">array[<span class="number">2</span>]=<span class="number">3</span>;</span><br><span class="line">array[<span class="number">3</span>]=<span class="number">4</span>;</span><br><span class="line">array[<span class="number">4</span>]=<span class="number">5</span>;</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//这种写法只能用于声明时初始化</span></span><br></pre></td></tr></table></figure></li><li><p>方法三：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array;</span><br><span class="line">array=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>获取数组长度</p><ul><li>理解数组是一个对象</li><li><code>arrayName.length</code></li></ul></li><li><p>数组复制</p><ul><li><code>System.arraycopy(源数组,源数组起始位置,目标数组,目标数组起始位置,要复制的数组元素数量);</code></li><li><code>目标数组=Arrays.copyOf(源数组，目标数组长度);</code></li></ul></li><li><p>数组排序</p><ul><li><code>Arrays.sort();</code></li></ul></li><li><p>多维数组</p><ul><li><p>java中只存在一维数组，多维数组只不过是数组中的数组</p></li><li><p>不规则数组创建</p><ul><li><p>方法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=&#123;&#123;<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">array[<span class="number">0</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;;</span><br><span class="line">array[<span class="number">1</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">array[<span class="number">2</span>]=<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>可变参数</p><ul><li><p>按照数组方式进行操作的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temp:data)&#123;</span><br><span class="line">        sum+=temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可变参数一定要定义在最后</p></li><li><p>一个方法只允许定义一个可变参数</p></li></ul></li><li><p>对象数组</p><ul><li>除了基本数据类型可以定义为数组，应用数据类型也可以定义数组</li><li>操作上同基本数据类型相同</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、java的基本元素&quot;&gt;&lt;a href=&quot;#一、java的基本元素&quot; class=&quot;headerlink&quot; title=&quot;一、java的基本元素&quot;&gt;&lt;/a&gt;一、java的基本元素&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;空白分隔符&lt;ul&gt;
&lt;li&gt;空格&lt;/li&gt;
&lt;li&gt;Ta
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="java" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/"/>
    
      <category term="基础语法" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/java/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="java笔记" scheme="https://huangdu.work/tags/java%E7%AC%94%E8%AE%B0/"/>
    
      <category term="基础语法" scheme="https://huangdu.work/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>makedown笔记</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/makedown/makedown%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangdu.work/笔记/makedown/makedown笔记/</id>
    <published>2019-10-17T16:00:00.000Z</published>
    <updated>2019-10-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>以下语法在Typora编辑器测试显示正常</strong></p><h2 id="1-标题"><a href="#1-标题" class="headerlink" title="1 标题"></a>1 标题</h2><h3 id="1-1-使用-号标记"><a href="#1-1-使用-号标记" class="headerlink" title="1.1 使用#号标记"></a>1.1 使用#号标记</h3><ul><li><p><code>#</code> 一级标题</p></li><li><p><code>##</code> 二级标题</p></li><li><p><code>###</code> 三级标题</p></li><li><p><code>####</code> 四级标题</p></li><li><p><code>#####</code> 五级标题</p></li><li><p><code>######</code> 六级标题</p></li><li><p>标准语法一般在<code>#</code>后跟个空格再写文字</p><h3 id="1-2-使用-和-标记"><a href="#1-2-使用-和-标记" class="headerlink" title="1.2 使用=和-标记"></a>1.2 使用=和-标记</h3></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">==</span><br><span class="line">二级标题</span><br><span class="line">--</span><br></pre></td></tr></table></figure></li><li><p><code>=</code>号和<code>-</code>号另起一行并大于等于两个</p></li></ul><h2 id="2-段落"><a href="#2-段落" class="headerlink" title="2 段落"></a>2 段落</h2><h3 id="2-1-换行"><a href="#2-1-换行" class="headerlink" title="2.1 换行"></a>2.1 换行</h3><ul><li>使用两个以上空格加上回车</li><li>两个段落直接加入空行<h3 id="2-2-字体"><a href="#2-2-字体" class="headerlink" title="2.2 字体"></a>2.2 字体</h3></li><li><code>*斜体*</code></li><li><code>**加粗**</code></li><li><code>***斜体加粗***</code></li><li>以上<code>*</code>换成<code>_</code>也可以</li><li><code>~~删除线~~</code></li><li><code>&lt;u&gt;下划线&lt;/u&gt;</code><h3 id="2-3-分割线"><a href="#2-3-分割线" class="headerlink" title="2.3 分割线"></a>2.3 分割线</h3></li><li><code>***</code></li><li><code>___</code> </li><li>同行用三个以上的<code>*</code>或<code>-</code>或<code>_</code>来建立分隔线 </li><li>可以在其中间插入空格，但行内不能有其他东西</li><li>使用<code>-</code>创建分割线时前面需有一空行<h3 id="2-4-脚注"><a href="#2-4-脚注" class="headerlink" title="2.4 脚注"></a>2.4 脚注</h3></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这句话的末尾添加了脚注[^脚注名]。    </span><br><span class="line">[^脚注名]:在这里写脚注的内容。</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3 列表"></a>3 列表</h2><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br></pre></td></tr></table></figure></li><li><p><code>-</code> <code>+</code> <code>*</code> 跟内容之间都要有一个空格</p><h3 id="3-2-有序列表"><a href="#3-2-有序列表" class="headerlink" title="3.2 有序列表"></a>3.2 有序列表</h3></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br></pre></td></tr></table></figure></li><li><p>序号跟内容之间要有空格</p></li><li><p>列表可嵌套：下级需要相对于上级缩进四个空格</p></li></ul><h2 id="4-区块"><a href="#4-区块" class="headerlink" title="4 区块"></a>4 区块</h2><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是区块的内容</span><br><span class="line">&gt;&gt; 区块可以嵌套</span><br><span class="line">&gt;&gt;&gt; 而且貌似可以无限嵌套</span><br></pre></td></tr></table></figure></li><li><p>列表和区块可互相嵌套</p></li></ul><h2 id="5-代码"><a href="#5-代码" class="headerlink" title="5 代码"></a>5 代码</h2><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`单行代码`</span><br><span class="line">​```java</span><br><span class="line">多行代码1</span><br><span class="line">多行代码2</span><br><span class="line">​```</span><br></pre></td></tr></table></figure></li><li><p>加语言类型代码高亮，也可不加</p></li><li><p>代码区块也可使用4个空格或者一个制表符</p></li></ul><h2 id="6-超链接"><a href="#6-超链接" class="headerlink" title="6 超链接"></a>6 超链接</h2><h3 id="6-1-一般用法"><a href="#6-1-一般用法" class="headerlink" title="6.1 一般用法"></a>6.1 一般用法</h3><ul><li><code>[超链接名](超链接地址 &quot;title&quot;)</code></li><li>title可加可不加<h3 id="6-2-高级用法"><a href="#6-2-高级用法" class="headerlink" title="6.2 高级用法"></a>6.2 高级用法</h3></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[超链接名][变量名]</span><br><span class="line">[变量名]: 超链接地址</span><br></pre></td></tr></table></figure></li></ul><h2 id="7-图片"><a href="#7-图片" class="headerlink" title="7 图片"></a>7 图片</h2><ul><li><code>![alt](图片地址 &quot;title&quot;)</code></li><li>title可加可不加</li><li>也可以使用类似于超链接高级用法使用</li><li>还可以直接使用<code>&lt;img src=&quot;&quot; width=&quot;&quot;/&gt;</code>标签</li></ul><h2 id="8-表格"><a href="#8-表格" class="headerlink" title="8 表格"></a>8 表格</h2><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|表头1|表头2|表头3|</span><br><span class="line">|:-|:-:|-:| </span><br><span class="line">|内容1|内容2|内容3|</span><br><span class="line">|内容4|内容5|内容6|</span><br></pre></td></tr></table></figure></li><li><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行</p></li><li><p><code>:-</code>文字居右 <code>:-:</code>文字居中 <code>-:</code>文字居右 <code>-</code>默认文字居左</p></li></ul><h2 id="9-高级技巧"><a href="#9-高级技巧" class="headerlink" title="9 高级技巧"></a>9 高级技巧</h2><h3 id="9-1-支持的-HTML-元素"><a href="#9-1-支持的-HTML-元素" class="headerlink" title="9.1 支持的 HTML 元素"></a>9.1 支持的 HTML 元素</h3><ul><li><code>&lt;kbd&gt;</code> <code>&lt;b&gt;</code> <code>&lt;i&gt;</code> <code>&lt;em&gt;</code> <code>&lt;sup&gt;</code> <code>&lt;sub&gt;</code> <code>&lt;br&gt;</code>等<h3 id="9-2-转义"><a href="#9-2-转义" class="headerlink" title="9.2 转义"></a>9.2 转义</h3></li><li>使用反斜杠转义特殊字符<h3 id="9-3-公式"><a href="#9-3-公式" class="headerlink" title="9.3 公式"></a>9.3 公式</h3></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">1+1=2</span><br><span class="line">$$</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-4-流程图"><a href="#9-4-流程图" class="headerlink" title="9.4 流程图"></a>9.4 流程图</h3><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">​```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes or No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">​```</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;以下语法在Typora编辑器测试显示正常&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-标题&quot;&gt;&lt;a href=&quot;#1-标题&quot; class=&quot;headerlink&quot; title=&quot;1 标题&quot;&gt;&lt;/a&gt;1 标题&lt;/h2&gt;&lt;h3 id=&quot;1-1-使用-号标记&quot;&gt;
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="makedown" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/makedown/"/>
    
    
      <category term="makedown" scheme="https://huangdu.work/tags/makedown/"/>
    
  </entry>
  
  <entry>
    <title>docker笔记</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/docker/docker%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangdu.work/笔记/docker/docker笔记/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-10-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、docker安装"><a href="#一、docker安装" class="headerlink" title="一、docker安装"></a>一、docker安装</h2><ol><li>win10家庭版装docker  <a href="https://www.jianshu.com/p/a24c5974067f" target="_blank" rel="noopener">原文链接</a></li></ol><ul><li><p>新建cmd文件，内容如下，以管理员身份运行。  </p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pushd</span> "%~dp0"</span><br><span class="line"><span class="built_in">dir</span> /b <span class="variable">%SystemRoot%</span>\servicing\Packages\*Hyper-V*.mum &gt;hyper-v.txt</span><br><span class="line"><span class="keyword">for</span> /f <span class="variable">%%i</span> <span class="keyword">in</span> ('<span class="built_in">findstr</span> /i . hyper-v.txt <span class="number">2</span>^&gt;<span class="built_in">nul</span>') <span class="keyword">do</span> dism /online   /norestart /add-package:"<span class="variable">%SystemRoot%</span>\servicing\Packages\<span class="variable">%%i</span>"</span><br><span class="line"><span class="built_in">del</span> hyper-v.txt</span><br><span class="line">Dism /online /enable-feature /featurename:Microsoft-Hyper-V-All     /LimitAccess /ALL</span><br></pre></td></tr></table></figure></li><li><p>修改注册表<code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion</code>路径下<code>EditionID</code>值为<code>Professional</code>。</p></li><li><p><a href="https://www.docker.com/get-started" target="_blank" rel="noopener">docker官网</a>点击<code>Download Desktop and Take a Tutorial</code>下载安装。</p></li></ul><ol start="2"><li>其它系统安装   <a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li></ol><h2 id="二、docker使用"><a href="#二、docker使用" class="headerlink" title="二、docker使用"></a>二、docker使用</h2><p>本笔记参照：<a href="https://www.runoob.com/docker/docker-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p><h3 id="Docker-Hello-World"><a href="#Docker-Hello-World" class="headerlink" title="Docker Hello World"></a>Docker Hello World</h3><ol><li>Hello World<br> <code>docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;</code></li><li>运行交互式的容器<br> <code>docker run -i -t ubuntu:15.10 /bin/bash</code></li><li>启动容器(后台模式)<ul><li>创建一个以进程方式运行的容器<br><code>docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</code></li><li>查看运行中的容器   <code>docker ps</code></li><li>查看容器的标准输出  <code>docker logs [ID|NAMES]</code></li><li>停止容器   <code>docker stop [ID|NAMES]</code></li></ul></li></ol><h3 id="Docker-容器使用"><a href="#Docker-容器使用" class="headerlink" title="Docker 容器使用"></a>Docker 容器使用</h3><ol><li>Docker客户端<ul><li>查看Docker客户端的所有命令选项 <code>docker</code></li><li>查看指定命令的使用方法    <code>docker [command] --help</code></li></ul></li><li>Web应用<ul><li>载入Web应用镜像  <code>docker pull training/webapp</code></li><li>运行应用(-P 容器内部端口随机映射到主机的高端口)<br><code>docker run -d -P training/webapp python app.py</code> </li><li>查看Web应用容器(加-l参数查询最后创建的)    <code>docker ps</code></li><li>设置指定端口(-p)<br><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li><li>查看网络端口的快捷方式    <code>docker port [ID|NAMES]</code></li><li>查看日志(和上面的有所区别加了-f参数)   <code>docker logs -f [ID|NAMES]</code></li><li>查看容器运行的进程  <code>docker top [ID|NAMES]</code></li><li>检查Web应用    <code>docker inspect [ID|NAMES]</code></li><li>停止、重启、移出   <code>docker stop|start|restart|rm [ID|NAMES]</code></li></ul></li></ol><h3 id="Docker-镜像使用"><a href="#Docker-镜像使用" class="headerlink" title="Docker 镜像使用"></a>Docker 镜像使用</h3><ol><li>列出镜像列表   <code>docker images</code></li><li>查找镜像<ul><li><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a></li><li><code>docker search [repname]</code></li></ul></li><li>获取一个新的镜像 <code>docker pull [repname]</code></li><li>更新镜像(先用镜像创建容器，在运行的容器中使用) <code>apt-get update</code><ul><li>提交到本地<br><code>docker commit -m=&quot;message&quot; -a=&quot;username&quot; [ID] [username]/[repname]:[tag]</code></li><li>提交到Docker Hub远程仓库<br><code>docker push [ID]</code></li></ul></li><li>设置镜像标签<br><code>docker tag [ID] [username]/[repname]:[tag]</code></li><li>构建镜像<br><code>docker build -t [username]/[repname]:[tag] [Dockerfile path]</code><br>Dockerfile文件实例：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM    centos:6.7</span><br><span class="line">MAINTAINER      Fisher <span class="string">"fisher@sudops.com"</span></span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'root:123456'</span> |chpasswd</span><br><span class="line">RUN     useradd runoob</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> <span class="string">'runoob:123456'</span> |chpasswd</span><br><span class="line">RUN     /bin/<span class="built_in">echo</span> -e <span class="string">"LANG=\"en_US.UTF-8\""</span> &gt;/etc/default/<span class="built_in">local</span></span><br><span class="line">EXPOSE  22</span><br><span class="line">EXPOSE  80</span><br><span class="line">CMD     /usr/sbin/sshd -D</span><br></pre></td></tr></table></figure></li></ol><h3 id="Docker-容器连接"><a href="#Docker-容器连接" class="headerlink" title="Docker 容器连接"></a>Docker 容器连接</h3><ol><li>网络端口映射<ul><li>随机映射端口<br><code>docker run -d -P training/webapp python app.py</code></li><li>映射指定端口<br><code>docker run -d -p 5000:5000 training/webapp python app.py</code></li><li>指定容器绑定的IP<br><code>docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</code></li><li>绑定UDP端口(默认TCP)<br><code>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</code></li></ul></li><li>Docker容器连接<ul><li>端口映射并不是唯一把 docker 连接到另一个容器的方法。</li><li>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。</li><li>docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。</li></ul></li><li>容器命名<br><code>docker run -d -P --name runoob training/webapp python app.py</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、docker安装&quot;&gt;&lt;a href=&quot;#一、docker安装&quot; class=&quot;headerlink&quot; title=&quot;一、docker安装&quot;&gt;&lt;/a&gt;一、docker安装&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;win10家庭版装docker  &lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="docker" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/docker/"/>
    
    
      <category term="docker" scheme="https://huangdu.work/tags/docker/"/>
    
      <category term="部署" scheme="https://huangdu.work/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>git笔记</title>
    <link href="https://huangdu.work/%E7%AC%94%E8%AE%B0/git/git%E7%AC%94%E8%AE%B0/"/>
    <id>https://huangdu.work/笔记/git/git笔记/</id>
    <published>2019-10-15T16:00:00.000Z</published>
    <updated>2019-10-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、-git"><a href="#一、-git" class="headerlink" title="一、 git"></a>一、 git</h2><ol><li>初始化<br> <code>git init</code></li><li>设置签名<ul><li>项目级别/仓库级别<br><code>git config user.name</code><br><code>git config user.email</code></li><li>系统用户级别<br><code>git config --global user.name</code><br><code>git config --global user.email</code></li><li>查看已有配置信息<br><code>git config --list</code></li></ul></li><li>查看状态<br> <code>git status</code></li><li>暂存区<ul><li>添加<br><code>git add</code>     </li><li>删除<br><code>git rm</code></li><li>提交<br><code>git commit</code></li></ul></li><li>历史记录<br> <code>git log</code><br> <code>git log --pretty=oneline</code><br> <code>git reflog</code></li><li>前进和后退<br> <code>git reset --hard</code></li><li>分支管理<ul><li>创建分支<br><code>git branch</code></li><li>切换分支<br><code>git checkout</code></li><li>查看分支<br><code>git branch -v</code></li><li>比较差异<br><code>git diff</code><br><code>git log -p</code></li><li>合并分支<br><code>git merge</code></li><li>冲突解决<ol><li>编辑文件，删除特殊符号</li><li>把文件修改到满意的程度，保存退出</li><li><code>git add [文件名]</code></li><li><code>git commit -m &quot;日志信息&quot;</code> (此时 commit 一定不能带具体文件名)</li></ol></li></ul></li></ol><h2 id="二、github"><a href="#二、github" class="headerlink" title="二、github"></a>二、github</h2><ol><li>远程地址加别名<br> <code>git remote add [别名] [远程地址]</code></li><li>查看远程地址别名<br> <code>git remote -v</code></li><li>将本地库内容推送到github中<br> <code>git push -u [远程地址/别名] master</code></li><li>克隆github中内容到本地库<br> <code>git clone [远程地址/别名]</code></li><li>更新本地库从github<br> <code>git fetch</code> add <code>git merge</code><br> or <code>git pull</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、-git&quot;&gt;&lt;a href=&quot;#一、-git&quot; class=&quot;headerlink&quot; title=&quot;一、 git&quot;&gt;&lt;/a&gt;一、 git&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;初始化&lt;br&gt; &lt;code&gt;git init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;设置签名&lt;ul&gt;

      
    
    </summary>
    
    
      <category term="笔记" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="git" scheme="https://huangdu.work/categories/%E7%AC%94%E8%AE%B0/git/"/>
    
    
      <category term="git" scheme="https://huangdu.work/tags/git/"/>
    
      <category term="版本控制" scheme="https://huangdu.work/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
</feed>
